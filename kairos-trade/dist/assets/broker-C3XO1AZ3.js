import{B as h}from"./index-DHdulUEJ.js";class G{constructor(){this.connections=new Map}_decrypt(c){return{...c,apiKey:atob(c.apiKey),apiSecret:atob(c.apiSecret),passphrase:c.passphrase?atob(c.passphrase):void 0}}async _coinbaseJWT(c,s,n){const i=c.apiKey,a=c.apiSecret,r={alg:"ES256",kid:i,nonce:crypto.randomUUID(),typ:"JWT"},t=Math.floor(Date.now()/1e3),e=`${s} api.coinbase.com${n}`,o={sub:i,iss:"coinbase-cloud",aud:["cdp_service"],nbf:t,exp:t+120,uri:e},l=E=>btoa(E).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),m=E=>l(JSON.stringify(E)),y=E=>l(String.fromCharCode(...new Uint8Array(E))),u=m(r),f=m(o),w=`${u}.${f}`,k=await this._importECKey(a),$=await crypto.subtle.sign({name:"ECDSA",hash:"SHA-256"},k,new TextEncoder().encode(w));return`${w}.${y($)}`}async _importECKey(c){const s=c.replace(/-----BEGIN (?:EC )?PRIVATE KEY-----/g,"").replace(/-----END (?:EC )?PRIVATE KEY-----/g,"").replace(/\\n/g,"").replace(/\n/g,"").replace(/\r/g,"").replace(/\s/g,""),n=Uint8Array.from(atob(s),e=>e.charCodeAt(0));if(c.includes("BEGIN PRIVATE KEY")&&!c.includes("EC PRIVATE KEY"))return crypto.subtle.importKey("pkcs8",n.buffer,{name:"ECDSA",namedCurve:"P-256"},!1,["sign"]);const i=this._extractEC_d(n),a=this._extractEC_pub(n);if(!i||i.length!==32)throw new Error(`Clave EC inválida: se esperaban 32 bytes para d, se encontraron ${(i==null?void 0:i.length)||0}`);const r=e=>btoa(String.fromCharCode(...e)).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),t={kty:"EC",crv:"P-256",d:r(i)};if(a&&a.length===65&&a[0]===4)t.x=r(a.slice(1,33)),t.y=r(a.slice(33,65));else return this._importECKeyPkcs8Wrap(n);return crypto.subtle.importKey("jwk",t,{name:"ECDSA",namedCurve:"P-256"},!1,["sign"])}_extractEC_d(c){for(let s=0;s<c.length-34;s++)if(c[s]===2&&c[s+1]===1&&c[s+2]===1&&c[s+3]===4&&c[s+4]===32)return c.slice(s+5,s+5+32);return null}_extractEC_pub(c){for(let s=0;s<c.length-67;s++)if(c[s]===161&&c[s+2]===3&&c[s+3]===66&&c[s+4]===0)return c.slice(s+5,s+5+65);return null}async _importECKeyPkcs8Wrap(c){const s=c.length,n=new Uint8Array([48,19,6,7,42,134,72,206,61,2,1,6,8,42,134,72,206,61,3,1,7]),i=new Uint8Array([2,1,0]),a=this._asn1Len(4,s),r=i.length+n.length+a.length+s,t=this._asn1Len(48,r),e=new Uint8Array(t.length+r);let o=0;return e.set(t,o),o+=t.length,e.set(i,o),o+=i.length,e.set(n,o),o+=n.length,e.set(a,o),o+=a.length,e.set(c,o),crypto.subtle.importKey("pkcs8",e.buffer,{name:"ECDSA",namedCurve:"P-256"},!1,["sign"])}_asn1Len(c,s){return s<128?new Uint8Array([c,s]):s<256?new Uint8Array([c,129,s]):new Uint8Array([c,130,s>>8&255,s&255])}async _coinbaseRequest(c,s,n,i=null){const a=await this._coinbaseJWT(c,s,n),r="/api/coinbase-proxy";try{const t=await fetch(r,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jwt:a,method:s,path:n,body:i})});let e;const o=await t.text();try{e=JSON.parse(o)}catch{e={error:o}}if(!t.ok)throw new Error(e.error||e.message||`Coinbase HTTP ${t.status}`);return e}catch(t){throw t.message==="Failed to fetch"||t.name==="TypeError"?new Error("Error de red al conectar con el proxy. Reintenta en unos segundos."):t}}async _hmacSign(c,s){const n=new TextEncoder,i=await crypto.subtle.importKey("raw",n.encode(c),{name:"HMAC",hash:"SHA-256"},!1,["sign"]),a=await crypto.subtle.sign("HMAC",i,n.encode(s));return Array.from(new Uint8Array(a)).map(r=>r.toString(16).padStart(2,"0")).join("")}async _hmacSignB64(c,s,n=!1){const i=new TextEncoder;let a;if(n){const e=atob(c);a=new Uint8Array(e.length);for(let o=0;o<e.length;o++)a[o]=e.charCodeAt(o)}else a=i.encode(c);const r=await crypto.subtle.importKey("raw",a,{name:"HMAC",hash:"SHA-256"},!1,["sign"]),t=await crypto.subtle.sign("HMAC",r,i.encode(s));return btoa(String.fromCharCode(...new Uint8Array(t)))}async _hmacSignSHA512B64(c,s){const n=atob(c),i=new Uint8Array(n.length);for(let e=0;e<n.length;e++)i[e]=n.charCodeAt(e);const a=await crypto.subtle.importKey("raw",i,{name:"HMAC",hash:"SHA-512"},!1,["sign"]),r=typeof s=="string"?new TextEncoder().encode(s):s,t=await crypto.subtle.sign("HMAC",a,r);return btoa(String.fromCharCode(...new Uint8Array(t)))}async _sha256(c){const s=new TextEncoder().encode(c),n=await crypto.subtle.digest("SHA-256",s);return new Uint8Array(n)}async _proxyRequest(c,s,n={},i=null){const a=await fetch("/api/broker-proxy",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({url:c,method:s,headers:n,body:i})}),r=await a.text();let t;try{t=JSON.parse(r)}catch{t={error:r}}if(!a.ok)throw new Error(t.error||t.message||t.msg||`HTTP ${a.status}`);return t}async _bybitRequest(c,s,n,i={}){const a=Date.now().toString(),r="5000";let t="",e="";s==="GET"?t=Object.entries(i).filter(([,f])=>f!=null).map(([f,w])=>`${f}=${w}`).join("&"):e=JSON.stringify(i);const o=`${a}${c.apiKey}${r}${s==="GET"?t:e}`,l=await this._hmacSign(c.apiSecret,o),m=`${h.bybit.baseUrl}${n}${t?"?"+t:""}`,y={"X-BAPI-API-KEY":c.apiKey,"X-BAPI-SIGN":l,"X-BAPI-SIGN-TYPE":"2","X-BAPI-TIMESTAMP":a,"X-BAPI-RECV-WINDOW":r,"Content-Type":"application/json"},u=await this._proxyRequest(m,s,y,s!=="GET"?i:null);if(u.retCode!==0&&u.retCode!==void 0)throw new Error(`Bybit: ${u.retMsg||"Unknown error"} (${u.retCode})`);return u.result||u}async _krakenRequest(c,s,n={}){const i=Date.now().toString(),a=new URLSearchParams({...n,nonce:i}).toString(),r=await this._sha256(i+a),t=new TextEncoder().encode(s),e=new Uint8Array(t.length+r.length);e.set(t,0),e.set(r,t.length);const o=await this._hmacSignSHA512B64(c.apiSecret,e),l=`${h.kraken.baseUrl}${s}`,m={"API-Key":c.apiKey,"API-Sign":o,"Content-Type":"application/x-www-form-urlencoded"},y=await this._proxyRequest(l,"POST",m,a);if(y.error&&y.error.length>0)throw new Error(`Kraken: ${y.error.join(", ")}`);return y.result||y}async _kucoinRequest(c,s,n,i={}){const a=Date.now().toString();let r="",t="";s==="GET"||s==="DELETE"?(t=Object.entries(i).filter(([,f])=>f!=null).map(([f,w])=>`${f}=${w}`).join("&"),t&&(n=`${n}?${t}`)):r=JSON.stringify(i);const e=`${a}${s}${n}${r}`,o=await this._hmacSignB64(c.apiSecret,e),l=await this._hmacSignB64(c.apiSecret,c.passphrase||""),m=`${h.kucoin.baseUrl}${n}`,y={"KC-API-KEY":c.apiKey,"KC-API-SIGN":o,"KC-API-TIMESTAMP":a,"KC-API-PASSPHRASE":l,"KC-API-KEY-VERSION":"2","Content-Type":"application/json"},u=await this._proxyRequest(m,s,y,s!=="GET"&&s!=="DELETE"?i:null);if(u.code&&u.code!=="200000")throw new Error(`KuCoin: ${u.msg||"Unknown error"} (${u.code})`);return u.data||u}async _okxRequest(c,s,n,i={}){const a=new Date().toISOString();let r="",t="";s==="GET"?(t=Object.entries(i).filter(([,u])=>u!=null).map(([u,f])=>`${u}=${f}`).join("&"),t&&(n=`${n}?${t}`)):r=JSON.stringify(i);const e=`${a}${s}${n}${r}`,o=await this._hmacSignB64(c.apiSecret,e),l=`${h.okx.baseUrl}${n}`,m={"OK-ACCESS-KEY":c.apiKey,"OK-ACCESS-SIGN":o,"OK-ACCESS-TIMESTAMP":a,"OK-ACCESS-PASSPHRASE":c.passphrase||"","Content-Type":"application/json"},y=await this._proxyRequest(l,s,m,s!=="GET"?i:null);if(y.code&&y.code!=="0")throw new Error(`OKX: ${y.msg||"Unknown error"} (${y.code})`);return y.data||y}async _bingxRequest(c,s,n,i={}){const a=Date.now().toString(),r={...i,timestamp:a},t=Object.entries(r).sort(([u],[f])=>u.localeCompare(f)).filter(([,u])=>u!=null).map(([u,f])=>`${u}=${encodeURIComponent(f)}`).join("&"),e=await this._hmacSign(c.apiSecret,t),o=`${t}&signature=${e}`,l=`${h.bingx.baseUrl}${n}?${o}`,m={"X-BX-APIKEY":c.apiKey,"Content-Type":"application/json"},y=await this._proxyRequest(l,s,m,s!=="GET"?i:null);if(y.code&&y.code!==0)throw new Error(`BingX: ${y.msg||"Unknown error"} (${y.code})`);return y.data||y}async _bitgetRequest(c,s,n,i={}){const a=Date.now().toString();let r="",t="";s==="GET"?(t=Object.entries(i).filter(([,u])=>u!=null).map(([u,f])=>`${u}=${f}`).join("&"),t&&(n=`${n}?${t}`)):r=JSON.stringify(i);const e=`${a}${s}${n}${r}`,o=await this._hmacSignB64(c.apiSecret,e),l=`${h.bitget.baseUrl}${n}`,m={"ACCESS-KEY":c.apiKey,"ACCESS-SIGN":o,"ACCESS-TIMESTAMP":a,"ACCESS-PASSPHRASE":c.passphrase||"","Content-Type":"application/json",locale:"en-US"},y=await this._proxyRequest(l,s,m,s!=="GET"?i:null);if(y.code&&y.code!=="00000")throw new Error(`Bitget: ${y.msg||"Unknown error"} (${y.code})`);return y.data||y}async _mexcRequest(c,s,n,i={}){const a=Date.now(),r={...i,timestamp:a,recvWindow:5e3},t=Object.entries(r).filter(([,f])=>f!=null).map(([f,w])=>`${f}=${encodeURIComponent(w)}`).join("&"),e=await this._hmacSign(c.apiSecret,t),o=`${t}&signature=${e}`,l=s==="GET"?`${h.mexc.baseUrl}${n}?${o}`:`${h.mexc.baseUrl}${n}`,m={"X-MEXC-APIKEY":c.apiKey,"Content-Type":"application/json"},y=s!=="GET"?o:null,u=await this._proxyRequest(l,s,m,y);if(u.code&&u.code!==0&&u.code!==200)throw new Error(`MEXC: ${u.msg||"Unknown error"} (${u.code})`);return u}async _binanceSignedRequest(c,s,n,i={}){const a=Date.now(),r={...i,timestamp:a,recvWindow:5e3},t=Object.entries(r).filter(([,f])=>f!=null).map(([f,w])=>`${f}=${encodeURIComponent(w)}`).join("&"),e=await this._hmacSign(c.apiSecret,t),o=`${t}&signature=${e}`,l=s==="GET"?`${h.binance.baseUrl}${n}?${o}`:`${h.binance.baseUrl}${n}`,m={method:s,headers:{"X-MBX-APIKEY":c.apiKey,"Content-Type":"application/x-www-form-urlencoded"}};(s==="POST"||s==="DELETE")&&(m.body=o);const y=await fetch(l,m),u=await y.json();if(!y.ok)throw new Error(`Binance ${n}: ${u.msg||y.statusText} (${u.code||y.status})`);return u}async _binancePublicRequest(c,s={}){const n=Object.entries(s).filter(([,r])=>r!==void 0).map(([r,t])=>`${r}=${encodeURIComponent(t)}`).join("&"),i=`${h.binance.baseUrl}${c}${n?"?"+n:""}`,a=await fetch(i);if(!a.ok)throw new Error(`Binance API error: ${a.status}`);return a.json()}async connect(c){var i,a,r,t;const s=this._decrypt(c),n=h[c.brokerId];if(!n)throw new Error(`Unsupported broker: ${c.brokerId}`);try{switch(c.brokerId){case"binance":{await this._binancePublicRequest("/api/v3/ping");const e=await this._binanceSignedRequest(s,"GET","/api/v3/account");return this.connections.set(c.id,{creds:s,config:n,connected:!0,permissions:e.permissions||[],accountType:e.accountType}),{success:!0,message:`Connected to Binance (${e.accountType})`,permissions:e.permissions}}case"coinbase":{const e=await this._coinbaseRequest(s,"GET","/api/v3/brokerage/accounts?limit=250");return this.connections.set(c.id,{creds:s,config:n,connected:!0,permissions:["read","trade"],accounts:e.accounts||[]}),{success:!0,message:`Connected to Coinbase (${(e.accounts||[]).length} accounts)`,permissions:["read","trade"]}}case"bybit":{const e=await this._bybitRequest(s,"GET","/v5/account/wallet-balance",{accountType:"UNIFIED"}),o=((r=(a=(i=e==null?void 0:e.list)==null?void 0:i[0])==null?void 0:a.coin)==null?void 0:r.length)||0;return this.connections.set(c.id,{creds:s,config:n,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to Bybit (${o} assets)`,permissions:["read","trade"]}}case"kraken":{const e=await this._krakenRequest(s,"/0/private/Balance"),o=Object.keys(e||{}).length;return this.connections.set(c.id,{creds:s,config:n,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to Kraken (${o} assets)`,permissions:["read","trade"]}}case"kucoin":{const e=await this._kucoinRequest(s,"GET","/api/v1/accounts"),o=Array.isArray(e)?e.length:0;return this.connections.set(c.id,{creds:s,config:n,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to KuCoin (${o} accounts)`,permissions:["read","trade"]}}case"okx":{const e=await this._okxRequest(s,"GET","/api/v5/account/balance"),o=Array.isArray(e)&&((t=e[0])!=null&&t.details)?e[0].details.length:0;return this.connections.set(c.id,{creds:s,config:n,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to OKX (${o} assets)`,permissions:["read","trade"]}}case"bingx":{const e=await this._bingxRequest(s,"GET","/openApi/spot/v1/account/balance"),o=Array.isArray(e==null?void 0:e.balances)?e.balances.filter(l=>parseFloat(l.free)>0).length:0;return this.connections.set(c.id,{creds:s,config:n,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to BingX (${o} assets)`,permissions:["read","trade"]}}case"bitget":{const e=await this._bitgetRequest(s,"GET","/api/v2/spot/account/assets"),o=Array.isArray(e)?e.filter(l=>parseFloat(l.available)>0).length:0;return this.connections.set(c.id,{creds:s,config:n,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to Bitget (${o} assets)`,permissions:["read","trade"]}}case"mexc":{const e=await this._mexcRequest(s,"GET","/api/v3/account"),o=Array.isArray(e==null?void 0:e.balances)?e.balances.filter(l=>parseFloat(l.free)>0).length:0;return this.connections.set(c.id,{creds:s,config:n,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to MEXC (${o} assets)`,permissions:["read","trade"]}}default:return await fetch(n.baseUrl),this.connections.set(c.id,{creds:s,config:n,connected:!0,permissions:[]}),{success:!0,message:`Connected to ${n.name}`}}}catch(e){return{success:!1,message:e.message}}}async getBalances(c){var n,i,a;const s=this.connections.get(c);if(!s)throw new Error("Broker not connected");if(s.config.id==="binance")try{return(await this._binanceSignedRequest(s.creds,"GET","/api/v3/account")).balances.filter(t=>parseFloat(t.free)>0||parseFloat(t.locked)>0).map(t=>({asset:t.asset,free:t.free,locked:t.locked,total:(parseFloat(t.free)+parseFloat(t.locked)).toString()}))}catch(r){throw console.error("Binance getBalances error:",r),r}if(s.config.id==="coinbase")try{return((await this._coinbaseRequest(s.creds,"GET","/api/v3/brokerage/accounts?limit=250")).accounts||[]).map(o=>{var l,m,y,u;return{asset:o.currency,free:((l=o.available_balance)==null?void 0:l.value)||"0",locked:((m=o.hold)==null?void 0:m.value)||"0",total:(parseFloat(((y=o.available_balance)==null?void 0:y.value)||0)+parseFloat(((u=o.hold)==null?void 0:u.value)||0)).toString(),name:o.name}}).filter(o=>parseFloat(o.free)>0||parseFloat(o.locked)>0)}catch(r){throw console.error("Coinbase getBalances:",r),r}if(s.config.id==="bybit")try{const r=await this._bybitRequest(s.creds,"GET","/v5/account/wallet-balance",{accountType:"UNIFIED"});return(((i=(n=r==null?void 0:r.list)==null?void 0:n[0])==null?void 0:i.coin)||[]).filter(e=>parseFloat(e.walletBalance)>0).map(e=>({asset:e.coin,free:e.availableToWithdraw||e.walletBalance||"0",locked:(parseFloat(e.walletBalance||0)-parseFloat(e.availableToWithdraw||0)).toString(),total:e.walletBalance||"0"}))}catch(r){throw console.error("Bybit getBalances:",r),r}if(s.config.id==="kraken")try{const r=await this._krakenRequest(s.creds,"/0/private/Balance"),t={XXBT:"BTC",XETH:"ETH",ZUSD:"USD",XXRP:"XRP",XLTC:"LTC",XXLM:"XLM",XDOGE:"DOGE"};return Object.entries(r||{}).filter(([,e])=>parseFloat(e)>0).map(([e,o])=>({asset:t[e]||e.replace(/^[XZ]/,""),free:o,locked:"0",total:o}))}catch(r){throw console.error("Kraken getBalances:",r),r}if(s.config.id==="kucoin")try{const r=await this._kucoinRequest(s.creds,"GET","/api/v1/accounts",{type:"trade"});return(Array.isArray(r)?r:[]).filter(t=>parseFloat(t.balance)>0).map(t=>({asset:t.currency,free:t.available||"0",locked:t.holds||"0",total:t.balance||"0"}))}catch(r){throw console.error("KuCoin getBalances:",r),r}if(s.config.id==="okx")try{const r=await this._okxRequest(s.creds,"GET","/api/v5/account/balance");return(Array.isArray(r)&&((a=r[0])!=null&&a.details)?r[0].details:[]).filter(e=>parseFloat(e.cashBal)>0).map(e=>({asset:e.ccy,free:e.availBal||e.cashBal||"0",locked:e.frozenBal||"0",total:e.cashBal||"0"}))}catch(r){throw console.error("OKX getBalances:",r),r}if(s.config.id==="bingx")try{const r=await this._bingxRequest(s.creds,"GET","/openApi/spot/v1/account/balance");return((r==null?void 0:r.balances)||(Array.isArray(r)?r:[])).filter(e=>parseFloat(e.free||e.available||0)>0).map(e=>({asset:e.asset||e.currency,free:e.free||e.available||"0",locked:e.locked||e.freeze||"0",total:(parseFloat(e.free||e.available||0)+parseFloat(e.locked||e.freeze||0)).toString()}))}catch(r){throw console.error("BingX getBalances:",r),r}if(s.config.id==="bitget")try{const r=await this._bitgetRequest(s.creds,"GET","/api/v2/spot/account/assets");return(Array.isArray(r)?r:[]).filter(e=>parseFloat(e.available||0)>0).map(e=>({asset:e.coin||e.coinName,free:e.available||"0",locked:e.frozen||e.lock||"0",total:(parseFloat(e.available||0)+parseFloat(e.frozen||e.lock||0)).toString()}))}catch(r){throw console.error("Bitget getBalances:",r),r}if(s.config.id==="mexc")try{const r=await this._mexcRequest(s.creds,"GET","/api/v3/account");return(Array.isArray(r==null?void 0:r.balances)?r.balances:[]).filter(e=>parseFloat(e.free||0)>0).map(e=>({asset:e.asset,free:e.free||"0",locked:e.locked||"0",total:(parseFloat(e.free||0)+parseFloat(e.locked||0)).toString()}))}catch(r){throw console.error("MEXC getBalances:",r),r}return[]}async placeOrder(c,s){var m,y,u,f,w,k,$,E,x,D,q,U,R,v,P,L,B;const n=this.connections.get(c);if(!n)throw new Error("Broker not connected");const{symbol:i,side:a,type:r,quantity:t,price:e,stopLoss:o,takeProfit:l}=s;if(!i||!a||!r||!t)throw new Error("Missing required order fields");if(n.config.id==="binance")try{const p={market:"MARKET",limit:"LIMIT",stop_loss:"STOP_LOSS_LIMIT"}[r]||"MARKET",g={symbol:i,side:a.toUpperCase(),type:p,quantity:t.toString()};(p==="LIMIT"||p==="STOP_LOSS_LIMIT")&&(g.timeInForce="GTC",g.price=parseFloat(e).toFixed(2)),p==="STOP_LOSS_LIMIT"&&(g.stopPrice=parseFloat(o||e).toFixed(2));const d=await this._binanceSignedRequest(n.creds,"POST","/api/v3/order",g);return{id:(m=d.orderId)==null?void 0:m.toString(),clientOrderId:d.clientOrderId,symbol:d.symbol,side:(y=d.side)==null?void 0:y.toLowerCase(),type:(u=d.type)==null?void 0:u.toLowerCase(),quantity:parseFloat(d.origQty||t),price:parseFloat(d.price||e||0),filledPrice:parseFloat(((w=(f=d.fills)==null?void 0:f[0])==null?void 0:w.price)||d.price||0),filledQty:parseFloat(d.executedQty||0),status:(k=d.status)==null?void 0:k.toLowerCase(),timestamp:new Date(d.transactTime||Date.now()).toISOString(),broker:"Binance",real:!0,raw:d}}catch(p){throw console.error("Binance placeOrder error:",p),p}if(n.config.id==="coinbase")try{const p=i.replace(/([A-Z]+)(USDT|USDC|USD|BTC|ETH)$/i,"$1-$2").toUpperCase(),g={};r==="market"?a.toLowerCase()==="buy"?g.market_market_ioc={quote_size:(parseFloat(t)*parseFloat(e||0)).toFixed(2)}:g.market_market_ioc={base_size:parseFloat(t).toString()}:r==="limit"&&(g.limit_limit_gtc={base_size:parseFloat(t).toString(),limit_price:parseFloat(e).toFixed(2)});const d={client_order_id:crypto.randomUUID(),product_id:p,side:a.toUpperCase(),order_configuration:g},S=await this._coinbaseRequest(n.creds,"POST","/api/v3/brokerage/orders",d);if(!S.success){const _=(($=S.error_response)==null?void 0:$.error)||((E=S.failure_response)==null?void 0:E.error)||((x=S.error_response)==null?void 0:x.message)||S.error||"Unknown error",F=((D=S.error_response)==null?void 0:D.error_details)||((q=S.failure_response)==null?void 0:q.message)||"";throw console.error("[COINBASE ORDER] FAILED:",_,F),new Error(`Coinbase order failed: ${_}${F?" — "+F:""}`)}const I=S.success_response||S,A=I.order_id||I.id;if(!A)throw console.error("[COINBASE ORDER] No order_id in response:",S),new Error("Coinbase: no order_id returned");let C=0,b=0,T="unknown";for(let _=0;_<3;_++)try{_>0&&await new Promise(K=>setTimeout(K,500));const F=await this._coinbaseRequest(n.creds,"GET",`/api/v3/brokerage/orders/historical/${A}`),O=F.order||F;if(T=(O.status||"").toUpperCase(),C=parseFloat(O.average_filled_price||0),b=parseFloat(O.filled_size||0),T==="FILLED"||T==="CANCELLED"||b>0)break}catch(F){console.warn(`[COINBASE ORDER] Detail fetch attempt ${_+1} failed:`,F.message)}return b===0&&C===0&&(console.warn("[COINBASE ORDER] Could not confirm fill for",A,"- status:",T),C=parseFloat(e||0),b=parseFloat(t),T="UNCONFIRMED"),{id:A,clientOrderId:d.client_order_id,symbol:p,side:a.toLowerCase(),type:r,quantity:b,price:C,filledPrice:C,filledQty:b,status:T.toLowerCase(),confirmed:T!=="UNCONFIRMED",timestamp:new Date().toISOString(),broker:"Coinbase",real:!0}}catch(p){throw console.error("[COINBASE ORDER] placeOrder error:",p.message),p}if(n.config.id==="bybit")try{const p=i.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase(),g={category:"spot",symbol:p,side:a.charAt(0).toUpperCase()+a.slice(1).toLowerCase(),orderType:r==="market"?"Market":"Limit",qty:t.toString()};r==="market"&&a.toLowerCase()==="buy"&&(g.marketUnit="quoteCoin",g.qty=(parseFloat(t)*parseFloat(e||0)).toFixed(2)),r==="limit"&&(g.price=parseFloat(e).toFixed(2),g.timeInForce="GTC");const S=(await this._bybitRequest(n.creds,"POST","/v5/order/create",g)).orderId||Date.now().toString(36);let I=parseFloat(e||0),A=parseFloat(t);try{await new Promise(T=>setTimeout(T,500));const C=await this._bybitRequest(n.creds,"GET","/v5/order/realtime",{category:"spot",orderId:S}),b=(U=C==null?void 0:C.list)==null?void 0:U[0];b&&(I=parseFloat(b.avgPrice||b.price||e||0),A=parseFloat(b.cumExecQty||t))}catch{}return{id:S,symbol:p,side:a.toLowerCase(),type:r,quantity:A,price:I,filledPrice:I,filledQty:A,status:"filled",timestamp:new Date().toISOString(),broker:"Bybit",real:!0}}catch(p){throw console.error("Bybit placeOrder:",p),p}if(n.config.id==="kraken")try{const p=i.replace("BTC","XBT"),g={pair:p,type:a.toLowerCase(),ordertype:r==="market"?"market":"limit",volume:t.toString()};r==="limit"&&(g.price=parseFloat(e).toFixed(2));const d=await this._krakenRequest(n.creds,"/0/private/AddOrder",g);return{id:((R=d==null?void 0:d.txid)==null?void 0:R[0])||Date.now().toString(36),symbol:p,side:a.toLowerCase(),type:r,quantity:parseFloat(t),price:parseFloat(e||0),filledPrice:parseFloat(e||0),filledQty:parseFloat(t),status:"filled",timestamp:new Date().toISOString(),broker:"Kraken",real:!0}}catch(p){throw console.error("Kraken placeOrder:",p),p}if(n.config.id==="kucoin")try{const p=i.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase(),g={clientOid:crypto.randomUUID(),symbol:p,side:a.toLowerCase(),type:r==="market"?"market":"limit"};r==="market"?a.toLowerCase()==="buy"?g.funds=(parseFloat(t)*parseFloat(e||0)).toFixed(2):g.size=t.toString():(g.price=parseFloat(e).toFixed(2),g.size=t.toString());const d=await this._kucoinRequest(n.creds,"POST","/api/v1/orders",g);return{id:(d==null?void 0:d.orderId)||Date.now().toString(36),symbol:p,side:a.toLowerCase(),type:r,quantity:parseFloat(t),price:parseFloat(e||0),filledPrice:parseFloat(e||0),filledQty:parseFloat(t),status:"filled",timestamp:new Date().toISOString(),broker:"KuCoin",real:!0}}catch(p){throw console.error("KuCoin placeOrder:",p),p}if(n.config.id==="okx")try{const p=i.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase(),g={instId:p,tdMode:"cash",side:a.toLowerCase(),ordType:r==="market"?"market":"limit",sz:t.toString()};r==="market"&&a.toLowerCase()==="buy"&&(g.tgtCcy="quote_ccy",g.sz=(parseFloat(t)*parseFloat(e||0)).toFixed(2)),r==="limit"&&(g.px=parseFloat(e).toFixed(2));const d=await this._okxRequest(n.creds,"POST","/api/v5/trade/order",g),S=Array.isArray(d)?(v=d[0])==null?void 0:v.ordId:(d==null?void 0:d.ordId)||Date.now().toString(36);if(Array.isArray(d)&&((P=d[0])==null?void 0:P.sCode)!=="0")throw new Error(`OKX order failed: ${(L=d[0])==null?void 0:L.sMsg}`);return{id:S,symbol:p,side:a.toLowerCase(),type:r,quantity:parseFloat(t),price:parseFloat(e||0),filledPrice:parseFloat(e||0),filledQty:parseFloat(t),status:"filled",timestamp:new Date().toISOString(),broker:"OKX",real:!0}}catch(p){throw console.error("OKX placeOrder:",p),p}if(n.config.id==="bingx")try{const p=i.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase(),g={symbol:p,side:a.toUpperCase(),type:r==="market"?"MARKET":"LIMIT"};r==="market"?a.toLowerCase()==="buy"?g.quoteOrderQty=(parseFloat(t)*parseFloat(e||0)).toFixed(2):g.quantity=parseFloat(t).toString():(g.price=parseFloat(e).toFixed(2),g.quantity=parseFloat(t).toString());const d=await this._bingxRequest(n.creds,"POST","/openApi/spot/v1/trade/order",g),S=(d==null?void 0:d.orderId)||((B=d==null?void 0:d.data)==null?void 0:B.orderId)||Date.now().toString(36);return{id:S==null?void 0:S.toString(),symbol:p,side:a.toLowerCase(),type:r,quantity:parseFloat(t),price:parseFloat(e||0),filledPrice:parseFloat((d==null?void 0:d.price)||e||0),filledQty:parseFloat((d==null?void 0:d.executedQty)||t),status:"filled",timestamp:new Date().toISOString(),broker:"BingX",real:!0}}catch(p){throw console.error("BingX placeOrder:",p),p}if(n.config.id==="bitget")try{const p=i.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase(),g={symbol:p,side:a.toLowerCase(),orderType:r==="market"?"market":"limit",force:"gtc",size:t.toString()};r==="market"&&a.toLowerCase()==="buy"&&(g.size=(parseFloat(t)*parseFloat(e||0)).toFixed(2)),r==="limit"&&(g.price=parseFloat(e).toFixed(2));const d=await this._bitgetRequest(n.creds,"POST","/api/v2/spot/trade/place-order",g),S=(d==null?void 0:d.orderId)||Date.now().toString(36);return{id:S==null?void 0:S.toString(),symbol:p,side:a.toLowerCase(),type:r,quantity:parseFloat(t),price:parseFloat(e||0),filledPrice:parseFloat(e||0),filledQty:parseFloat(t),status:"filled",timestamp:new Date().toISOString(),broker:"Bitget",real:!0}}catch(p){throw console.error("Bitget placeOrder:",p),p}if(n.config.id==="mexc")try{const p=i.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase(),g={symbol:p,side:a.toUpperCase(),type:r==="market"?"MARKET":"LIMIT"};r==="market"?a.toLowerCase()==="buy"?g.quoteOrderQty=(parseFloat(t)*parseFloat(e||0)).toFixed(2):g.quantity=parseFloat(t).toString():(g.price=parseFloat(e).toFixed(2),g.quantity=parseFloat(t).toString(),g.timeInForce="GTC");const d=await this._mexcRequest(n.creds,"POST","/api/v3/order",g),S=(d==null?void 0:d.orderId)||Date.now().toString(36);return{id:S==null?void 0:S.toString(),symbol:p,side:a.toLowerCase(),type:r,quantity:parseFloat(t),price:parseFloat(e||0),filledPrice:parseFloat((d==null?void 0:d.price)||e||0),filledQty:parseFloat((d==null?void 0:d.executedQty)||t),status:"filled",timestamp:new Date().toISOString(),broker:"MEXC",real:!0}}catch(p){throw console.error("MEXC placeOrder:",p),p}if(n.config.id==="wallet")try{const p=n.chainId||56,g=n.creds.apiSecret,d=await walletBroker.placeOrder(g,p,{symbol:i,side:a,type:"market",quantity:t,price:e});if(!d.success)throw new Error(d.error||"DEX swap failed");return{id:d.txHash||Date.now().toString(36),symbol:d.symbol||i,side:a.toLowerCase(),type:"market",quantity:parseFloat(d.amountIn||t),price:parseFloat(d.effectivePrice||e||0),filledPrice:parseFloat(d.effectivePrice||e||0),filledQty:parseFloat(d.amountOut||t),status:"filled",timestamp:new Date().toISOString(),broker:"Kairos Wallet",real:!0,txHash:d.txHash,chain:d.chain}}catch(p){throw console.error("Wallet DEX placeOrder:",p),p}return{id:Date.now().toString(36),symbol:i,side:a,type:r,quantity:parseFloat(t),price:e?parseFloat(e):null,status:r==="market"?"filled":"new",filledPrice:r==="market"?parseFloat(e||0):null,timestamp:new Date().toISOString(),broker:n.config.name,simulated:!0}}async cancelOrder(c,s,n){const i=this.connections.get(c);if(!i)throw new Error("Broker not connected");if(i.config.id==="binance")try{const a=await this._binanceSignedRequest(i.creds,"DELETE","/api/v3/order",{symbol:n,orderId:s});return{success:!0,orderId:a.orderId,status:a.status}}catch(a){return{success:!1,message:a.message}}if(i.config.id==="coinbase")try{return await this._coinbaseRequest(i.creds,"POST","/api/v3/brokerage/orders/batch_cancel",{order_ids:[s]}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(i.config.id==="bybit")try{return await this._bybitRequest(i.creds,"POST","/v5/order/cancel",{category:"spot",symbol:n,orderId:s}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(i.config.id==="kraken")try{return await this._krakenRequest(i.creds,"/0/private/CancelOrder",{txid:s}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(i.config.id==="kucoin")try{return await this._kucoinRequest(i.creds,"DELETE",`/api/v1/orders/${s}`),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(i.config.id==="okx")try{return await this._okxRequest(i.creds,"POST","/api/v5/trade/cancel-order",{instId:n,ordId:s}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(i.config.id==="bingx")try{return await this._bingxRequest(i.creds,"POST","/openApi/spot/v1/trade/cancel",{symbol:n,orderId:s}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(i.config.id==="bitget")try{return await this._bitgetRequest(i.creds,"POST","/api/v2/spot/trade/cancel-order",{symbol:n,orderId:s}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(i.config.id==="mexc")try{return await this._mexcRequest(i.creds,"DELETE","/api/v3/order",{symbol:n,orderId:s}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}return i.config.id==="wallet"?{success:!1,message:"DEX orders are instant swaps and cannot be cancelled"}:{success:!0,orderId:s,simulated:!0}}async getOpenOrders(c,s){const n=this.connections.get(c);if(!n)throw new Error("Broker not connected");if(n.config.id==="binance")try{const i=s?{symbol:s}:{};return(await this._binanceSignedRequest(n.creds,"GET","/api/v3/openOrders",i)).map(r=>{var t,e,o,l;return{id:(t=r.orderId)==null?void 0:t.toString(),symbol:r.symbol,side:(e=r.side)==null?void 0:e.toLowerCase(),type:(o=r.type)==null?void 0:o.toLowerCase(),quantity:parseFloat(r.origQty),price:parseFloat(r.price),filledQty:parseFloat(r.executedQty),status:(l=r.status)==null?void 0:l.toLowerCase(),time:new Date(r.time).toISOString()}})}catch{return[]}if(n.config.id==="coinbase")try{const i=s?s.replace(/([A-Z]+)(USDT|USDC|USD|BTC|ETH)$/i,"$1-$2").toUpperCase():void 0;let a="/api/v3/brokerage/orders/historical/batch?order_status=OPEN";return i&&(a+=`&product_id=${i}`),((await this._coinbaseRequest(n.creds,"GET",a)).orders||[]).map(t=>{var e,o,l,m,y,u,f;return{id:t.order_id,symbol:t.product_id,side:(e=t.side)==null?void 0:e.toLowerCase(),type:(o=t.order_type)==null?void 0:o.toLowerCase(),quantity:parseFloat(((m=(l=t.order_configuration)==null?void 0:l.limit_limit_gtc)==null?void 0:m.base_size)||0),price:parseFloat(((u=(y=t.order_configuration)==null?void 0:y.limit_limit_gtc)==null?void 0:u.limit_price)||t.average_filled_price||0),filledQty:parseFloat(t.filled_size||0),status:(f=t.status)==null?void 0:f.toLowerCase(),time:t.created_time}})}catch(i){return console.error("[COINBASE] getOpenOrders error:",i.message),[]}if(n.config.id==="bybit")try{const i={category:"spot"};s&&(i.symbol=s);const a=await this._bybitRequest(n.creds,"GET","/v5/order/realtime",i);return((a==null?void 0:a.list)||[]).map(r=>{var t,e,o;return{id:r.orderId,symbol:r.symbol,side:(t=r.side)==null?void 0:t.toLowerCase(),type:(e=r.orderType)==null?void 0:e.toLowerCase(),quantity:parseFloat(r.qty||0),price:parseFloat(r.price||0),filledQty:parseFloat(r.cumExecQty||0),status:(o=r.orderStatus)==null?void 0:o.toLowerCase(),time:r.createdTime?new Date(parseInt(r.createdTime)).toISOString():null}})}catch(i){return console.error("Bybit getOpenOrders:",i.message),[]}if(n.config.id==="kraken")try{const i=await this._krakenRequest(n.creds,"/0/private/OpenOrders"),a=(i==null?void 0:i.open)||{};return Object.entries(a).map(([r,t])=>{var e,o,l,m,y,u,f;return{id:r,symbol:((e=t.descr)==null?void 0:e.pair)||"",side:(l=(o=t.descr)==null?void 0:o.type)==null?void 0:l.toLowerCase(),type:(y=(m=t.descr)==null?void 0:m.ordertype)==null?void 0:y.toLowerCase(),quantity:parseFloat(t.vol||0),price:parseFloat(((u=t.descr)==null?void 0:u.price)||0),filledQty:parseFloat(t.vol_exec||0),status:((f=t.status)==null?void 0:f.toLowerCase())||"open",time:t.opentm?new Date(t.opentm*1e3).toISOString():null}})}catch(i){return console.error("Kraken getOpenOrders:",i.message),[]}if(n.config.id==="kucoin")try{const i={status:"active"};s&&(i.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const a=await this._kucoinRequest(n.creds,"GET","/api/v1/orders",i);return(Array.isArray(a==null?void 0:a.items)?a.items:Array.isArray(a)?a:[]).map(t=>{var e,o;return{id:t.id,symbol:t.symbol,side:(e=t.side)==null?void 0:e.toLowerCase(),type:(o=t.type)==null?void 0:o.toLowerCase(),quantity:parseFloat(t.size||0),price:parseFloat(t.price||0),filledQty:parseFloat(t.dealSize||0),status:t.isActive?"open":"done",time:t.createdAt?new Date(parseInt(t.createdAt)).toISOString():null}})}catch(i){return console.error("KuCoin getOpenOrders:",i.message),[]}if(n.config.id==="okx")try{const i={instType:"SPOT"};s&&(i.instId=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const a=await this._okxRequest(n.creds,"GET","/api/v5/trade/orders-pending",i);return(Array.isArray(a)?a:[]).map(t=>{var e,o,l;return{id:t.ordId,symbol:t.instId,side:(e=t.side)==null?void 0:e.toLowerCase(),type:(o=t.ordType)==null?void 0:o.toLowerCase(),quantity:parseFloat(t.sz||0),price:parseFloat(t.px||0),filledQty:parseFloat(t.accFillSz||0),status:((l=t.state)==null?void 0:l.toLowerCase())||"open",time:t.cTime?new Date(parseInt(t.cTime)).toISOString():null}})}catch(i){return console.error("OKX getOpenOrders:",i.message),[]}if(n.config.id==="bingx")try{const i={};s&&(i.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const a=await this._bingxRequest(n.creds,"GET","/openApi/spot/v1/trade/openOrders",i);return((a==null?void 0:a.orders)||(Array.isArray(a)?a:[])).map(t=>{var e,o,l,m;return{id:(e=t.orderId)==null?void 0:e.toString(),symbol:t.symbol,side:(o=t.side)==null?void 0:o.toLowerCase(),type:(l=t.type)==null?void 0:l.toLowerCase(),quantity:parseFloat(t.origQty||0),price:parseFloat(t.price||0),filledQty:parseFloat(t.executedQty||0),status:((m=t.status)==null?void 0:m.toLowerCase())||"open",time:t.time?new Date(parseInt(t.time)).toISOString():null}})}catch(i){return console.error("BingX getOpenOrders:",i.message),[]}if(n.config.id==="bitget")try{const i={};s&&(i.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase());const a=await this._bitgetRequest(n.creds,"GET","/api/v2/spot/trade/unfilled-orders",i);return(Array.isArray(a)?a:[]).map(t=>{var e,o,l;return{id:t.orderId,symbol:t.symbol,side:(e=t.side)==null?void 0:e.toLowerCase(),type:(o=t.orderType)==null?void 0:o.toLowerCase(),quantity:parseFloat(t.size||0),price:parseFloat(t.price||0),filledQty:parseFloat(t.baseVolume||0),status:((l=t.status)==null?void 0:l.toLowerCase())||"open",time:t.cTime?new Date(parseInt(t.cTime)).toISOString():null}})}catch(i){return console.error("Bitget getOpenOrders:",i.message),[]}if(n.config.id==="mexc")try{const i={};s&&(i.symbol=s);const a=await this._mexcRequest(n.creds,"GET","/api/v3/openOrders",i);return(Array.isArray(a)?a:[]).map(t=>{var e,o,l,m;return{id:(e=t.orderId)==null?void 0:e.toString(),symbol:t.symbol,side:(o=t.side)==null?void 0:o.toLowerCase(),type:(l=t.type)==null?void 0:l.toLowerCase(),quantity:parseFloat(t.origQty||0),price:parseFloat(t.price||0),filledQty:parseFloat(t.executedQty||0),status:((m=t.status)==null?void 0:m.toLowerCase())||"open",time:t.time?new Date(t.time).toISOString():null}})}catch(i){return console.error("MEXC getOpenOrders:",i.message),[]}return[]}async getClosedOrders(c,s,n=50){const i=this.connections.get(c);if(!i)throw new Error("Broker not connected");const a=(r,t)=>{var e;return{id:((e=r[t.id])==null?void 0:e.toString())||"",symbol:r[t.symbol]||"",side:(r[t.side]||"").toLowerCase(),type:(r[t.type]||"").toLowerCase(),quantity:parseFloat(r[t.qty]||0),price:parseFloat(r[t.price]||0),filledQty:parseFloat(r[t.filledQty]||0),avgPrice:parseFloat(r[t.avgPrice]||r[t.price]||0),status:(r[t.status]||"closed").toLowerCase(),time:t.timeFn?t.timeFn(r):null}};if(i.config.id==="binance")try{const r={limit:n};s&&(r.symbol=s);const t=await this._binanceSignedRequest(i.creds,"GET","/api/v3/allOrders",r);return(Array.isArray(t)?t:[]).filter(o=>o.status!=="NEW"&&o.status!=="PARTIALLY_FILLED").map(o=>a(o,{id:"orderId",symbol:"symbol",side:"side",type:"type",qty:"origQty",price:"price",filledQty:"executedQty",avgPrice:"price",status:"status",timeFn:l=>l.time?new Date(l.time).toISOString():null}))}catch(r){return console.error("Binance getClosedOrders:",r.message),[]}if(i.config.id==="coinbase")try{const r={order_status:["FILLED","CANCELLED","EXPIRED"],limit:n};s&&(r.product_id=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const t=await this._coinbaseRequest(i.creds,"GET","/api/v3/brokerage/orders/historical/batch",r);return((t==null?void 0:t.orders)||[]).map(e=>a(e,{id:"order_id",symbol:"product_id",side:"side",type:"order_type",qty:"base_size",price:"average_filled_price",filledQty:"filled_size",avgPrice:"average_filled_price",status:"status",timeFn:o=>o.created_time||null}))}catch(r){return console.error("Coinbase getClosedOrders:",r.message),[]}if(i.config.id==="bybit")try{const r={category:"spot",limit:n.toString()};s&&(r.symbol=s);const t=await this._bybitRequest(i.creds,"GET","/v5/order/history",r);return((t==null?void 0:t.list)||[]).map(e=>a(e,{id:"orderId",symbol:"symbol",side:"side",type:"orderType",qty:"qty",price:"price",filledQty:"cumExecQty",avgPrice:"avgPrice",status:"orderStatus",timeFn:o=>o.createdTime?new Date(parseInt(o.createdTime)).toISOString():null}))}catch(r){return console.error("Bybit getClosedOrders:",r.message),[]}if(i.config.id==="kraken")try{const r=await this._krakenRequest(i.creds,"/0/private/ClosedOrders"),t=(r==null?void 0:r.closed)||{};return Object.entries(t).slice(0,n).map(([e,o])=>{var l,m,y,u,f;return{id:e,symbol:((l=o.descr)==null?void 0:l.pair)||"",side:(((m=o.descr)==null?void 0:m.type)||"").toLowerCase(),type:(((y=o.descr)==null?void 0:y.ordertype)||"").toLowerCase(),quantity:parseFloat(o.vol||0),price:parseFloat(((u=o.descr)==null?void 0:u.price)||0),filledQty:parseFloat(o.vol_exec||0),avgPrice:parseFloat(o.price||((f=o.descr)==null?void 0:f.price)||0),status:(o.status||"closed").toLowerCase(),time:o.closetm?new Date(o.closetm*1e3).toISOString():null}})}catch(r){return console.error("Kraken getClosedOrders:",r.message),[]}if(i.config.id==="kucoin")try{const r={status:"done"};s&&(r.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const t=await this._kucoinRequest(i.creds,"GET","/api/v1/orders",r);return(Array.isArray(t==null?void 0:t.items)?t.items:Array.isArray(t)?t:[]).slice(0,n).map(o=>a(o,{id:"id",symbol:"symbol",side:"side",type:"type",qty:"size",price:"price",filledQty:"dealSize",avgPrice:"dealFunds",status:"status",timeFn:l=>l.createdAt?new Date(parseInt(l.createdAt)).toISOString():null}))}catch(r){return console.error("KuCoin getClosedOrders:",r.message),[]}if(i.config.id==="okx")try{const r={instType:"SPOT"};s&&(r.instId=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const t=await this._okxRequest(i.creds,"GET","/api/v5/trade/orders-history-archive",r);return(Array.isArray(t)?t:[]).slice(0,n).map(o=>a(o,{id:"ordId",symbol:"instId",side:"side",type:"ordType",qty:"sz",price:"px",filledQty:"accFillSz",avgPrice:"avgPx",status:"state",timeFn:l=>l.cTime?new Date(parseInt(l.cTime)).toISOString():null}))}catch(r){return console.error("OKX getClosedOrders:",r.message),[]}if(i.config.id==="bingx")try{const r={limit:n.toString()};s&&(r.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const t=await this._bingxRequest(i.creds,"GET","/openApi/spot/v1/trade/historyOrders",r);return((t==null?void 0:t.orders)||(Array.isArray(t)?t:[])).map(o=>a(o,{id:"orderId",symbol:"symbol",side:"side",type:"type",qty:"origQty",price:"price",filledQty:"executedQty",avgPrice:"avgPrice",status:"status",timeFn:l=>l.time?new Date(parseInt(l.time)).toISOString():null}))}catch(r){return console.error("BingX getClosedOrders:",r.message),[]}if(i.config.id==="bitget")try{const r={limit:n.toString()};s&&(r.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase());const t=await this._bitgetRequest(i.creds,"GET","/api/v2/spot/trade/history-orders",r);return(Array.isArray(t)?t:[]).map(o=>a(o,{id:"orderId",symbol:"symbol",side:"side",type:"orderType",qty:"size",price:"price",filledQty:"baseVolume",avgPrice:"priceAvg",status:"status",timeFn:l=>l.cTime?new Date(parseInt(l.cTime)).toISOString():null}))}catch(r){return console.error("Bitget getClosedOrders:",r.message),[]}if(i.config.id==="mexc")try{const r={limit:n};s&&(r.symbol=s);const t=await this._mexcRequest(i.creds,"GET","/api/v3/allOrders",r);return(Array.isArray(t)?t:[]).filter(o=>o.status!=="NEW").map(o=>a(o,{id:"orderId",symbol:"symbol",side:"side",type:"type",qty:"origQty",price:"price",filledQty:"executedQty",avgPrice:"price",status:"status",timeFn:l=>l.time?new Date(l.time).toISOString():null}))}catch(r){return console.error("MEXC getClosedOrders:",r.message),[]}return[]}async getTradeHistory(c,s,n=50){const i=this.connections.get(c);if(!i)throw new Error("Broker not connected");if(i.config.id==="binance")try{return(await this._binanceSignedRequest(i.creds,"GET","/api/v3/myTrades",{symbol:s,limit:n})).map(r=>{var t,e;return{id:(t=r.id)==null?void 0:t.toString(),orderId:(e=r.orderId)==null?void 0:e.toString(),symbol:r.symbol,side:r.isBuyer?"buy":"sell",price:parseFloat(r.price),quantity:parseFloat(r.qty),commission:parseFloat(r.commission),commissionAsset:r.commissionAsset,time:new Date(r.time).toISOString(),isMaker:r.isMaker}})}catch{return[]}if(i.config.id==="coinbase")try{const a=s?s.replace(/([A-Z]+)(USDT|USDC|USD|BTC|ETH)$/i,"$1-$2").toUpperCase():void 0;let r=`/api/v3/brokerage/orders/historical/fills?limit=${n}`;return a&&(r+=`&product_id=${a}`),((await this._coinbaseRequest(i.creds,"GET",r)).fills||[]).map(e=>{var o,l,m;return{id:e.trade_id||e.entry_id,orderId:e.order_id,symbol:e.product_id,side:(o=e.side)==null?void 0:o.toLowerCase(),price:parseFloat(e.price||0),quantity:parseFloat(e.size||e.size_in_quote||0),commission:parseFloat(e.commission||0),commissionAsset:((m=(l=e.product_id)==null?void 0:l.split("-"))==null?void 0:m[1])||"USD",time:e.trade_time,isMaker:!1}})}catch(a){return console.error("[COINBASE] getTradeHistory error:",a.message),[]}if(i.config.id==="bybit")try{const a={category:"spot",limit:n.toString()};s&&(a.symbol=s);const r=await this._bybitRequest(i.creds,"GET","/v5/execution/list",a);return((r==null?void 0:r.list)||[]).map(t=>{var e;return{id:t.execId,orderId:t.orderId,symbol:t.symbol,side:(e=t.side)==null?void 0:e.toLowerCase(),price:parseFloat(t.execPrice||0),quantity:parseFloat(t.execQty||0),commission:parseFloat(t.execFee||0),commissionAsset:t.feeCurrency||"",time:t.execTime?new Date(parseInt(t.execTime)).toISOString():null,isMaker:t.isMaker==="true"||t.isMaker===!0}})}catch(a){return console.error("Bybit getTradeHistory:",a.message),[]}if(i.config.id==="kraken")try{const a=await this._krakenRequest(i.creds,"/0/private/TradesHistory"),r=(a==null?void 0:a.trades)||{};return Object.entries(r).slice(0,n).map(([t,e])=>{var o;return{id:t,orderId:e.ordertxid,symbol:e.pair,side:(o=e.type)==null?void 0:o.toLowerCase(),price:parseFloat(e.price||0),quantity:parseFloat(e.vol||0),commission:parseFloat(e.fee||0),commissionAsset:"",time:e.time?new Date(e.time*1e3).toISOString():null,isMaker:e.maker===!0}})}catch(a){return console.error("Kraken getTradeHistory:",a.message),[]}if(i.config.id==="kucoin")try{const a={};s&&(a.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const r=await this._kucoinRequest(i.creds,"GET","/api/v1/fills",a);return(Array.isArray(r==null?void 0:r.items)?r.items:Array.isArray(r)?r:[]).slice(0,n).map(e=>{var o;return{id:e.tradeId||e.id,orderId:e.orderId,symbol:e.symbol,side:(o=e.side)==null?void 0:o.toLowerCase(),price:parseFloat(e.price||0),quantity:parseFloat(e.size||0),commission:parseFloat(e.fee||0),commissionAsset:e.feeCurrency||"",time:e.createdAt?new Date(parseInt(e.createdAt)).toISOString():null,isMaker:e.liquidity==="maker"}})}catch(a){return console.error("KuCoin getTradeHistory:",a.message),[]}if(i.config.id==="okx")try{const a={instType:"SPOT"};s&&(a.instId=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const r=await this._okxRequest(i.creds,"GET","/api/v5/trade/fills-history",a);return(Array.isArray(r)?r:[]).slice(0,n).map(e=>{var o;return{id:e.tradeId||e.billId,orderId:e.ordId,symbol:e.instId,side:(o=e.side)==null?void 0:o.toLowerCase(),price:parseFloat(e.fillPx||0),quantity:parseFloat(e.fillSz||0),commission:Math.abs(parseFloat(e.fee||0)),commissionAsset:e.feeCcy||"",time:e.ts?new Date(parseInt(e.ts)).toISOString():null,isMaker:e.execType==="M"}})}catch(a){return console.error("OKX getTradeHistory:",a.message),[]}if(i.config.id==="bingx")try{const a={limit:n.toString()};s&&(a.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const r=await this._bingxRequest(i.creds,"GET","/openApi/spot/v1/trade/historyOrders",a);return((r==null?void 0:r.orders)||(Array.isArray(r)?r:[])).map(e=>{var o,l,m;return{id:(o=e.orderId)==null?void 0:o.toString(),orderId:(l=e.orderId)==null?void 0:l.toString(),symbol:e.symbol,side:(m=e.side)==null?void 0:m.toLowerCase(),price:parseFloat(e.price||e.avgPrice||0),quantity:parseFloat(e.executedQty||e.origQty||0),commission:parseFloat(e.commission||0),commissionAsset:e.commissionAsset||"",time:e.time?new Date(parseInt(e.time)).toISOString():null,isMaker:!1}})}catch(a){return console.error("BingX getTradeHistory:",a.message),[]}if(i.config.id==="bitget")try{const a={limit:n.toString()};s&&(a.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase());const r=await this._bitgetRequest(i.creds,"GET","/api/v2/spot/trade/fills",a);return(Array.isArray(r)?r:[]).map(e=>{var o;return{id:e.tradeId||e.fillId,orderId:e.orderId,symbol:e.symbol,side:(o=e.side)==null?void 0:o.toLowerCase(),price:parseFloat(e.priceAvg||e.price||0),quantity:parseFloat(e.size||0),commission:parseFloat(e.fees||e.fee||0),commissionAsset:e.feeCcy||"",time:e.cTime?new Date(parseInt(e.cTime)).toISOString():null,isMaker:e.tradeScope==="maker"}})}catch(a){return console.error("Bitget getTradeHistory:",a.message),[]}if(i.config.id==="mexc")try{const a={limit:n};s&&(a.symbol=s);const r=await this._mexcRequest(i.creds,"GET","/api/v3/myTrades",a);return(Array.isArray(r)?r:[]).map(e=>{var o,l;return{id:(o=e.id)==null?void 0:o.toString(),orderId:(l=e.orderId)==null?void 0:l.toString(),symbol:e.symbol,side:e.isBuyer?"buy":"sell",price:parseFloat(e.price||0),quantity:parseFloat(e.qty||0),commission:parseFloat(e.commission||0),commissionAsset:e.commissionAsset||"",time:e.time?new Date(e.time).toISOString():null,isMaker:e.isMaker===!0}})}catch(a){return console.error("MEXC getTradeHistory:",a.message),[]}return[]}async getExchangeInfo(c){var s,n,i,a;try{const t=(s=(await this._binancePublicRequest("/api/v3/exchangeInfo",{symbol:c})).symbols)==null?void 0:s[0];if(!t)return null;const e=(n=t.filters)==null?void 0:n.find(m=>m.filterType==="LOT_SIZE"),o=(i=t.filters)==null?void 0:i.find(m=>m.filterType==="PRICE_FILTER"),l=(a=t.filters)==null?void 0:a.find(m=>m.filterType==="NOTIONAL"||m.filterType==="MIN_NOTIONAL");return{symbol:t.symbol,status:t.status,baseAsset:t.baseAsset,quoteAsset:t.quoteAsset,minQty:e?parseFloat(e.minQty):0,maxQty:e?parseFloat(e.maxQty):1/0,stepSize:e?parseFloat(e.stepSize):0,minPrice:o?parseFloat(o.minPrice):0,tickSize:o?parseFloat(o.tickSize):0,minNotional:l?parseFloat(l.minNotional||l.notional):0}}catch{return null}}isConnected(c){return this.connections.has(c)}getConnection(c){return this.connections.get(c)}disconnect(c){this.connections.delete(c)}}const X=new G;export{X as b};
//# sourceMappingURL=broker-C3XO1AZ3.js.map
