const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-BbWcOjla.js","assets/index-BhWCJaKV.js","assets/ui-CUucduZ3.js","assets/vendor-B3xyLMQT.js","assets/index-DHfBpVOP.css","assets/provider-jsonrpc-BbN4VmB_.js","assets/walletConnectDApp-DdyjF_hI.js"])))=>i.map(i=>d[i]);
import{_ as Z,u as J,B as k,h as ce}from"./index-BhWCJaKV.js";const q=(...x)=>{},Q=(...x)=>{},ee={name:"0x",endpoints:{56:"https://bsc.api.0x.org",1:"https://api.0x.org",137:"https://polygon.api.0x.org",42161:"https://arbitrum.api.0x.org",8453:"https://base.api.0x.org"}},te={name:"1inch",endpoints:{56:"https://api.1inch.dev/swap/v6.0/56",1:"https://api.1inch.dev/swap/v6.0/1",137:"https://api.1inch.dev/swap/v6.0/137",42161:"https://api.1inch.dev/swap/v6.0/42161",8453:"https://api.1inch.dev/swap/v6.0/8453"}},V={name:"Paraswap",endpoints:{56:"https://apiv5.paraswap.io",1:"https://apiv5.paraswap.io",137:"https://apiv5.paraswap.io",42161:"https://apiv5.paraswap.io",8453:"https://apiv5.paraswap.io"}},Y="0xCee44904A6aA94dEa28754373887E07D4B6f4968",re=15,$={QUOTE_TIMEOUT_MS:8e3,EXECUTE_TIMEOUT_MS:6e4,MAX_RETRIES:2,RETRY_DELAY_MS:500,QUOTE_MAX_AGE_MS:15e3,CIRCUIT_BREAKER_THRESHOLD:3,CIRCUIT_BREAKER_RESET_MS:12e4,GAS_MULTIPLIER:1.5,PARALLEL_QUOTES:!0},H={"0x":{failures:0,lastFail:0,open:!1},"1inch":{failures:0,lastFail:0,open:!1},Paraswap:{failures:0,lastFail:0,open:!1}};function le(x){H[x]&&(H[x].failures=0,H[x].open=!1)}function de(x){const c=H[x];c&&(c.failures++,c.lastFail=Date.now(),c.failures>=$.CIRCUIT_BREAKER_THRESHOLD&&(c.open=!0,Q(`[CIRCUIT-BREAKER] ${x} marked DOWN (${c.failures} consecutive failures)`)))}function pe(x){const c=H[x];return!c||!c.open?!1:Date.now()-c.lastFail>$.CIRCUIT_BREAKER_RESET_MS?(c.open=!1,c.failures=0,!1):!0}function W(x,c,s){return Promise.race([fetch(x,c),new Promise((n,o)=>setTimeout(()=>o(new Error(`Timeout after ${s}ms`)),s))])}async function ue(x,c,s,n){let o;for(let a=0;a<=c;a++)try{return await x()}catch(r){o=r,a<c&&(Q(`[RETRY] ${n} attempt ${a+1}/${c} failed: ${r.message}. Retrying in ${s}ms...`),await new Promise(t=>setTimeout(t,s)))}throw o}let ae="aggregator";const G={56:{name:"BSC",rpc:["https://bsc-dataseed1.binance.org","https://bsc-dataseed2.binance.org","https://bsc-dataseed3.binance.org"],router:"0x10ED43C718714eb63d5aA57B78B54704E256024E",factory:"0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73",wrapped:"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",dexName:"PancakeSwap",explorer:"https://bscscan.com",nativeSymbol:"BNB"},1:{name:"Ethereum",rpc:["https://eth.llamarpc.com","https://rpc.ankr.com/eth"],router:"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D",factory:"0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f",wrapped:"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",dexName:"Uniswap",explorer:"https://etherscan.io",nativeSymbol:"ETH"},137:{name:"Polygon",rpc:["https://polygon-rpc.com","https://rpc.ankr.com/polygon"],router:"0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff",factory:"0x5757371414417b8C6CAad45bAeF941aBc7d3Ab32",wrapped:"0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",dexName:"QuickSwap",explorer:"https://polygonscan.com",nativeSymbol:"MATIC"},42161:{name:"Arbitrum",rpc:["https://arb1.arbitrum.io/rpc","https://rpc.ankr.com/arbitrum"],router:"0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506",factory:"0xc35DADB65012eC5796536bD9864eD8773aBc74C4",wrapped:"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",dexName:"SushiSwap",explorer:"https://arbiscan.io",nativeSymbol:"ETH"},43114:{name:"Avalanche",rpc:["https://api.avax.network/ext/bc/C/rpc","https://rpc.ankr.com/avalanche"],router:"0x60aE616a2155Ee3d9A68541Ba4544862310933d4",factory:"0x9Ad6C38BE94206cA50bb0d90783181834C6AbB96",wrapped:"0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",dexName:"Trader Joe",explorer:"https://snowtrace.io",nativeSymbol:"AVAX"},8453:{name:"Base",rpc:["https://mainnet.base.org","https://rpc.ankr.com/base"],router:"0x327Df1E6de05895d2ab08513aaDD9313fE505d86",factory:"0xFDa619b6d20975be80A10332cD39b9a4b0FAa8BB",wrapped:"0x4200000000000000000000000000000000000006",dexName:"BaseSwap",explorer:"https://basescan.org",nativeSymbol:"ETH"}},se={56:{USDT:"0x55d398326f99059fF775485246999027B3197955",USDC:"0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d",BUSD:"0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56",BTC:"0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c",ETH:"0x2170Ed0880ac9A755fd29B2688956BD959F933F8",KAIROS:"0x14D41707269c7D8b8DFa5095b38824a46dA05da3",BNB:"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c"},1:{USDT:"0xdAC17F958D2ee523a2206206994597C13D831ec7",USDC:"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",WETH:"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"},137:{USDT:"0xc2132D05D31c914a87C6611C10748AEb04B58e8F",USDC:"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",KAIROS:"0x9151B8C90B2F8a8DF82426E7E65d00563A75a6C9",WMATIC:"0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270"},42161:{USDT:"0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9",USDC:"0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8",KAIROS:"0x14D41707269c7D8b8DFa5095b38824a46dA05da3",WETH:"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1"},43114:{USDT:"0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7",USDC:"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",WAVAX:"0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7"},8453:{USDC:"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",WETH:"0x4200000000000000000000000000000000000006",KAIROS:"0x14D41707269c7D8b8DFa5095b38824a46dA05da3"}},N=["function balanceOf(address) view returns (uint256)","function decimals() view returns (uint8)","function symbol() view returns (string)","function name() view returns (string)","function allowance(address owner, address spender) view returns (uint256)","function approve(address spender, uint256 amount) returns (bool)"],oe=["function getAmountsOut(uint amountIn, address[] path) view returns (uint[] amounts)","function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] path, address to, uint deadline) returns (uint[] amounts)","function swapExactETHForTokens(uint amountOutMin, address[] path, address to, uint deadline) payable returns (uint[] amounts)","function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] path, address to, uint deadline) returns (uint[] amounts)","function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] path, address to, uint deadline)","function WETH() view returns (address)"];let X=null;async function K(){if(X)return X;try{return X=await Z(()=>import("./index-BbWcOjla.js"),__vite__mapDeps([0,1,2,3,4,5])),X}catch{if(window.ethers)return X=window.ethers,X;throw new Error("ethers.js not available. Install with: npm install ethers")}}class me{constructor(){this.providers={},this.wallets={},this.executionMode=ae}setExecutionMode(c){if(!["aggregator","direct"].includes(c))throw new Error('Invalid mode. Use "aggregator" or "direct"');this.executionMode=c,ae=c}getExecutionMode(){return this.executionMode}async _getAggregatorQuote(c,s,n,o){const a=[{...ee,method:"_quote0x"},{...te,method:"_quote1inch"},{...V,method:"_quoteParaswap"}];{const r=a.filter(i=>!pe(i.name)&&i.endpoints[c]);if(r.length===0)return null;const e=(await Promise.allSettled(r.map(i=>ue(()=>this[i.method](c,s,n,o),$.MAX_RETRIES,$.RETRY_DELAY_MS,i.name).then(l=>{if(l)return le(i.name),{...l,aggregator:i.name};throw new Error("Empty quote")}).catch(l=>{throw de(i.name),l})))).filter(i=>i.status==="fulfilled").map(i=>i.value).sort((i,l)=>{const p=BigInt(i.buyAmount||"0"),m=BigInt(l.buyAmount||"0");return m>p?1:m<p?-1:0});if(e.length>0){const i=e[0];return q(`[AGGREGATOR] Best quote from ${i.aggregator} (${e.length} sources responded)`),e.length>1&&q(`[AGGREGATOR] Compared: ${e.map(l=>`${l.aggregator}=${l.buyAmount}`).join(" vs ")}`),i}return null}}async _quote0x(c,s,n,o){const a=ee.endpoints[c];if(!a)return null;const r=new URLSearchParams({sellToken:s,buyToken:n,sellAmount:o.toString(),slippagePercentage:"0.005",feeRecipient:Y,buyTokenPercentageFee:(re/1e4).toString(),enableSlippageProtection:"true"}),t=await W(`${a}/swap/v1/quote?${r}`,{headers:{"0x-api-key":""}},$.QUOTE_TIMEOUT_MS);if(!t.ok){const l=await t.json().catch(()=>({}));throw new Error(`0x quote failed (${t.status}): ${(l==null?void 0:l.reason)||"Unknown"}`)}const e=await t.json(),i=(e.sources||[]).filter(l=>parseFloat(l.proportion)>0).map(l=>({name:l.name,pct:Math.round(parseFloat(l.proportion)*100)})).sort((l,p)=>p.pct-l.pct);return{buyAmount:e.buyAmount,to:e.to,data:e.data,value:e.value||"0",gasEstimate:e.estimatedGas,allowanceTarget:e.allowanceTarget,sources:i,sourceSummary:i.map(l=>`${l.name} ${l.pct}%`).join(" + ")||"Direct",price:e.price,guaranteedPrice:e.guaranteedPrice,quotedAt:Date.now()}}async _quote1inch(c,s,n,o){var i,l,p,m,d;const a=te.endpoints[c];if(!a)return null;const r=new URLSearchParams({src:s,dst:n,amount:o.toString(),from:Y,slippage:"0.5",fee:(re/100).toString(),referrerAddress:Y,disableEstimate:"true"}),t=await W(`${a}/swap?${r}`,{headers:{accept:"application/json"}},$.QUOTE_TIMEOUT_MS);if(!t.ok)throw new Error(`1inch quote failed (${t.status})`);const e=await t.json();return{buyAmount:e.dstAmount||e.toAmount||"0",to:((i=e.tx)==null?void 0:i.to)||e.to,data:((l=e.tx)==null?void 0:l.data)||e.data,value:((p=e.tx)==null?void 0:p.value)||"0",gasEstimate:((m=e.tx)==null?void 0:m.gas)||e.estimatedGas||"300000",allowanceTarget:((d=e.tx)==null?void 0:d.to)||e.to,sources:[{name:"1inch Router",pct:100}],sourceSummary:"1inch Aggregation",price:null,guaranteedPrice:null,quotedAt:Date.now()}}async _quoteParaswap(c,s,n,o){var l,p,m,d,g;const a=V.endpoints[c];if(!a)return null;const r=new URLSearchParams({srcToken:s,destToken:n,amount:o.toString(),srcDecimals:"18",destDecimals:"18",side:"SELL",network:c.toString(),partner:"kairos",version:"6.2"}),t=await W(`${a}/prices?${r}`,{headers:{accept:"application/json"}},$.QUOTE_TIMEOUT_MS);if(!t.ok)throw new Error(`Paraswap price failed (${t.status})`);const i=(await t.json()).priceRoute;if(!i)throw new Error("Paraswap: no route found");return{buyAmount:i.destAmount||"0",to:null,data:null,value:"0",gasEstimate:i.gasCost||"300000",allowanceTarget:i.tokenTransferProxy,sources:[{name:"Paraswap",pct:100}],sourceSummary:`Paraswap (${((g=(d=(m=(p=(l=i.bestRoute)==null?void 0:l[0])==null?void 0:p.swaps)==null?void 0:m[0])==null?void 0:d.swapExchanges)==null?void 0:g.map(w=>w.exchange).join("+"))||"multi"})`,price:null,guaranteedPrice:null,priceRoute:i,quotedAt:Date.now(),needsTxBuild:!0}}async _executeAggregatorSwap(c,s,n,o,a){const r=await K(),t=G[s],e=n.toLowerCase()===t.wrapped.toLowerCase();let i=a;if(Date.now()-(a.quotedAt||0)>$.QUOTE_MAX_AGE_MS){const d=await this._getAggregatorQuote(s,n,a._tokenOut||n,o);d&&d.data&&(i=d)}if(i.needsTxBuild&&i.priceRoute)try{const d=await W(`${V.endpoints[s]}/transactions/${s}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({srcToken:n,destToken:i._tokenOut,srcAmount:o.toString(),destAmount:i.buyAmount,priceRoute:i.priceRoute,userAddress:c.address,partner:"kairos"})},$.QUOTE_TIMEOUT_MS);if(d.ok){const g=await d.json();i.to=g.to,i.data=g.data,i.value=g.value||"0",i.gasEstimate=g.gas||i.gasEstimate}else throw new Error("Paraswap TX build failed")}catch(d){throw Q("[PARASWAP] TX build failed:",d.message),d}if(!i.to||!i.data)throw new Error("Quote has no execution data");if(!e&&i.allowanceTarget){const d=new r.Contract(n,N,c);await d.allowance(c.address,i.allowanceTarget)<BigInt(o)&&(q(`[AGGREGATOR] Approving token for ${i.sourceSummary}...`),await(await d.approve(i.allowanceTarget,r.MaxUint256)).wait())}const l=Math.ceil(Number(i.gasEstimate||3e5)*$.GAS_MULTIPLIER),p=await c.sendTransaction({to:i.to,data:i.data,value:i.value,gasLimit:l});q(`[AGGREGATOR] Swap tx: ${p.hash} via ${i.sourceSummary} (gas limit: ${l})`);const m=await p.wait();if(m.status===0)throw new Error(`TX reverted on-chain: ${p.hash}`);return{tx:p,receipt:m,sources:i.sources,sourceSummary:i.sourceSummary,aggregator:i.aggregator}}async _getProvider(c){if(this.providers[c])return this.providers[c];const s=await K(),n=G[c];if(!n)throw new Error(`Unsupported chain: ${c}`);for(const o of n.rpc)try{const a=new s.JsonRpcProvider(o,c);return await a.getBlockNumber(),this.providers[c]=a,a}catch{continue}throw new Error(`Could not connect to ${n.name} RPC`)}async _getWallet(c,s){const n=`${s}-${c.slice(-6)}`;if(this.wallets[n])return this.wallets[n];const o=await K(),a=await this._getProvider(s),r=new o.Wallet(c,a);return this.wallets[n]=r,r}_resolveToken(c,s){if(c!=null&&c.startsWith("0x")&&c.length===42)return c;const n=se[s]||{},o=(c||"").toUpperCase(),a=o.replace("KAIROS","").replace("USDT","").replace("USDC","");return n[o]||n[a]||null}async connect(c,s,n=56){try{const o=await K(),a=G[n];if(!a)return{success:!1,message:`Red no soportada: ${n}`};if(!o.isAddress(c))return{success:!1,message:"Dirección de wallet inválida"};try{if(new o.Wallet(s).address.toLowerCase()!==c.toLowerCase())return{success:!1,message:"La clave privada no corresponde a la dirección"}}catch{return{success:!1,message:"Clave privada inválida"}}const t=await(await this._getProvider(n)).getBalance(c),e=o.formatEther(t);return{success:!0,message:`Conectado a ${a.name} via ${this.executionMode==="aggregator"?"Kairos Exchange (100+ DEXes)":a.dexName} (${parseFloat(e).toFixed(4)} ${a.nativeSymbol})`,chain:a.name,dex:this.executionMode==="aggregator"?"Kairos Exchange":a.dexName,executionMode:this.executionMode,nativeBalance:e}}catch(o){return{success:!1,message:`Error: ${o.message}`}}}async getBalances(c,s=56){const n=await K(),o=await this._getProvider(s),a=G[s],r=se[s]||{},t=[];try{const e=await o.getBalance(c),i=n.formatEther(e);parseFloat(i)>0&&t.push({asset:a.nativeSymbol,free:i,locked:"0",total:i,native:!0})}catch(e){Q("Native balance error:",e.message)}for(const[e,i]of Object.entries(r))if(i.toLowerCase()!==a.wrapped.toLowerCase())try{const l=new n.Contract(i,N,o),[p,m]=await Promise.all([l.balanceOf(c),l.decimals()]),d=n.formatUnits(p,m);parseFloat(d)>1e-6&&t.push({asset:e,free:d,locked:"0",total:d})}catch(l){Q(`Token ${e} balance error:`,l.message)}return t}async getQuote(c,s,n,o){const a=await K(),r=await this._getProvider(c),t=G[c],e=this._resolveToken(s,c),i=this._resolveToken(n,c);if(!e||!i)throw new Error(`Token not found: ${s} or ${n}`);let l=18;e.toLowerCase()!==t.wrapped.toLowerCase()&&(l=await new a.Contract(e,N,r).decimals());let p=18;i.toLowerCase()!==t.wrapped.toLowerCase()&&(p=await new a.Contract(i,N,r).decimals());const m=a.parseUnits(o.toString(),l);if(this.executionMode==="aggregator")try{const g=await this._getAggregatorQuote(c,e,i,m);if(g){g._tokenOut=i;const w=a.formatUnits(g.buyAmount,p),C=parseFloat(w)/parseFloat(o);q(`[QUOTE] Aggregator → ${w} via ${g.sourceSummary}`);let E=null;try{E=await this._getDirectQuote(c,e,i,m,p,t)}catch{}const S=E?((parseFloat(w)-E.amountOutNum)/E.amountOutNum*100).toFixed(2):null;return{amountIn:o.toString(),amountOut:w,effectivePrice:C,dex:"Kairos Exchange",mode:"aggregator",sources:g.sources,sourceSummary:g.sourceSummary,priceImpact:"optimized",savingsVsDirect:S?`${S>0?"+":""}${S}%`:null,directDex:(E==null?void 0:E.dex)||null,_aggQuoteData:g}}}catch(g){Q("[QUOTE] Aggregator failed, falling back to direct DEX:",g.message)}const d=await this._getDirectQuote(c,e,i,m,p,t);return{amountIn:o.toString(),amountOut:d.formattedOut,effectivePrice:d.effectivePrice,path:d.path,dex:t.dexName,mode:"direct",sources:[{name:t.dexName,pct:100}],sourceSummary:t.dexName,priceImpact:d.path.length>2?"multi-hop":"direct",savingsVsDirect:null}}async _getDirectQuote(c,s,n,o,a,r){const t=await K(),e=await this._getProvider(c),i=new t.Contract(r.router,oe,e),l=[[s,n],[s,r.wrapped,n]];for(const p of l)try{const m=await i.getAmountsOut(o,p),d=m[m.length-1],g=t.formatUnits(d,a),w=parseFloat(g),C=w/parseFloat(t.formatUnits(o,18));return{formattedOut:g,effectivePrice:C,amountOutNum:w,path:p,dex:r.dexName}}catch{continue}throw new Error(`No liquidity found on ${r.dexName}`)}async placeOrder(c,s,n){var _,O;const o=await K(),a=G[s];if(!a)throw new Error(`Unsupported chain: ${s}`);const{symbol:r,side:t,quantity:e,price:i}=n;let l,p;const m=r.match(/^([A-Z]+)(USDT|USDC|BUSD|KAIROS|BNB|ETH|WETH|WBNB|MATIC|AVAX)$/i);if(m)l=m[1].toUpperCase(),p=m[2].toUpperCase(),p==="KAIROS"&&(p="USDT");else throw new Error(`Invalid pair format: ${r}. Expected e.g. BTCUSDT`);const d=this._resolveToken(l,s),g=this._resolveToken(p,s);if(!d)throw new Error(`Token ${l} not found on chain ${s}`);if(!g)throw new Error(`Token ${p} not found on chain ${s}`);const w=await this._getWallet(c,s);let C,E,S;t.toLowerCase()==="buy"?(C=g,E=d,S=(parseFloat(e)*parseFloat(i||1)).toString()):(C=d,E=g,S=e.toString());const R=C.toLowerCase()===a.wrapped.toLowerCase(),L=E.toLowerCase()===a.wrapped.toLowerCase();let U=18;R||(U=await new o.Contract(C,N,w.provider).decimals());let A=18;L||(A=await new o.Contract(E,N,w.provider).decimals());const F=o.parseUnits(S,U);if(this.executionMode==="aggregator")try{const b=await this._getAggregatorQuote(s,C,E,F);if(b){b._tokenOut=E,q(`[ORDER] Executing via ${b.aggregator||"Aggregator"} → ${b.sourceSummary}`);const T=await this._executeAggregatorSwap(w,s,C,F,b),M=o.formatUnits(b.buyAmount,A);return{success:!0,txHash:T.tx.hash,symbol:r,side:t.toLowerCase(),amountIn:S,amountOut:M,effectivePrice:t.toLowerCase()==="buy"?parseFloat(S)/parseFloat(M):parseFloat(M)/parseFloat(S),chain:a.name,dex:"Kairos Exchange",mode:"aggregator",aggregator:T.aggregator||b.aggregator||"0x",sources:T.sources,sourceSummary:T.sourceSummary,explorer:`${a.explorer}/tx/${T.tx.hash}`,gasUsed:(_=T.receipt.gasUsed)==null?void 0:_.toString(),blockNumber:T.receipt.blockNumber}}}catch(b){Q("[ORDER] Aggregator execution failed, falling back to direct DEX:",b.message)}q(`[ORDER] Executing via Direct → ${a.dexName}`);const B=new o.Contract(a.router,oe,w);let v;try{await B.getAmountsOut(F,[C,E]),v=[C,E]}catch{v=[C,a.wrapped,E];try{await B.getAmountsOut(F,v)}catch{throw new Error(`No liquidity for ${l}/${p} on ${a.dexName}`)}}const j=await B.getAmountsOut(F,v),z=j[j.length-1],f=z*BigInt(Math.floor((1-.5/100)*1e4))/10000n,u=Math.floor(Date.now()/1e3)+300;if(!R){const b=new o.Contract(C,N,w);await b.allowance(w.address,a.router)<F&&(q(`[WALLET] Approving ${l} for ${a.dexName}...`),await(await b.approve(a.router,o.MaxUint256)).wait())}let h;if(R)h=await B.swapExactETHForTokens(f,v,w.address,u,{value:F});else if(L)h=await B.swapExactTokensForETH(F,f,v,w.address,u);else try{h=await B.swapExactTokensForTokensSupportingFeeOnTransferTokens(F,f,v,w.address,u)}catch{h=await B.swapExactTokensForTokens(F,f,v,w.address,u)}q(`[WALLET] Swap tx: ${h.hash}`);const P=await h.wait(),D=o.formatUnits(z,A),I=parseFloat(D)/parseFloat(S);return{success:!0,txHash:h.hash,symbol:r,side:t.toLowerCase(),amountIn:S,amountOut:D,effectivePrice:t.toLowerCase()==="buy"?parseFloat(S)/parseFloat(D):I,chain:a.name,dex:a.dexName,mode:"direct",sources:[{name:a.dexName,pct:100}],sourceSummary:a.dexName,explorer:`${a.explorer}/tx/${h.hash}`,gasUsed:(O=P.gasUsed)==null?void 0:O.toString(),blockNumber:P.blockNumber}}async cancelOrder(){return{success:!1,message:"DEX swaps are instant and cannot be cancelled"}}async sendViaWalletConnect(c,s){try{const{sendTransaction:n}=await Z(async()=>{const{sendTransaction:r}=await import("./walletConnectDApp-DdyjF_hI.js");return{sendTransaction:r}},__vite__mapDeps([6,2])),o=await n(c,s),a=G[c];return{success:!0,txHash:o,explorer:a?`${a.explorer}/tx/${o}`:null,chain:(a==null?void 0:a.name)||`Chain ${c}`,method:"WalletConnect"}}catch(n){return{success:!1,message:`WalletConnect: ${n.message}`}}}async isWCAvailable(){try{const{isConnected:c}=await Z(async()=>{const{isConnected:s}=await import("./walletConnectDApp-DdyjF_hI.js");return{isConnected:s}},__vite__mapDeps([6,2]));return c()}catch{return!1}}async getWCAccount(){try{const{getConnectedAccount:c}=await Z(async()=>{const{getConnectedAccount:s}=await import("./walletConnectDApp-DdyjF_hI.js");return{getConnectedAccount:s}},__vite__mapDeps([6,2]));return c()}catch{return null}}getAggregatorStatus(){return{mode:this.executionMode,aggregators:Object.entries(H).map(([c,s])=>({name:c,status:s.open?"DOWN":"HEALTHY",consecutiveFailures:s.failures,lastFailure:s.lastFail?new Date(s.lastFail).toISOString():null,willResetAt:s.open?new Date(s.lastFail+$.CIRCUIT_BREAKER_RESET_MS).toISOString():null})),config:{...$}}}}const ge=new me,ie="https://kairos-api-u6k5.onrender.com";class ye{constructor(){this.connections=new Map}async _decrypt(c){var o;const s=`kairos:broker:${((o=J.getState().user)==null?void 0:o.email)||"anon"}`,n=async a=>{if(a){if(a.startsWith("v1:")){const{privateKey:r}=await ce(a,s);return r}try{return atob(a)}catch{return a}}};return{...c,apiKey:await n(c.apiKey),apiSecret:await n(c.apiSecret),passphrase:await n(c.passphrase)}}async _coinbaseJWT(c,s,n){const o=c.apiKey,a=c.apiSecret,r={alg:"ES256",kid:o,nonce:crypto.randomUUID(),typ:"JWT"},t=Math.floor(Date.now()/1e3),e=`${s} api.coinbase.com${n}`,i={sub:o,iss:"coinbase-cloud",aud:["cdp_service"],nbf:t,exp:t+120,uri:e},l=S=>btoa(S).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),p=S=>l(JSON.stringify(S)),m=S=>l(String.fromCharCode(...new Uint8Array(S))),d=p(r),g=p(i),w=`${d}.${g}`,C=await this._importECKey(a),E=await crypto.subtle.sign({name:"ECDSA",hash:"SHA-256"},C,new TextEncoder().encode(w));return`${w}.${m(E)}`}async _importECKey(c){const s=c.replace(/-----BEGIN (?:EC )?PRIVATE KEY-----/g,"").replace(/-----END (?:EC )?PRIVATE KEY-----/g,"").replace(/\\n/g,"").replace(/\n/g,"").replace(/\r/g,"").replace(/\s/g,""),n=Uint8Array.from(atob(s),e=>e.charCodeAt(0));if(c.includes("BEGIN PRIVATE KEY")&&!c.includes("EC PRIVATE KEY"))return crypto.subtle.importKey("pkcs8",n.buffer,{name:"ECDSA",namedCurve:"P-256"},!1,["sign"]);const o=this._extractEC_d(n),a=this._extractEC_pub(n);if(!o||o.length!==32)throw new Error(`Clave EC inválida: se esperaban 32 bytes para d, se encontraron ${(o==null?void 0:o.length)||0}`);const r=e=>btoa(String.fromCharCode(...e)).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),t={kty:"EC",crv:"P-256",d:r(o)};if(a&&a.length===65&&a[0]===4)t.x=r(a.slice(1,33)),t.y=r(a.slice(33,65));else return this._importECKeyPkcs8Wrap(n);return crypto.subtle.importKey("jwk",t,{name:"ECDSA",namedCurve:"P-256"},!1,["sign"])}_extractEC_d(c){for(let s=0;s<c.length-34;s++)if(c[s]===2&&c[s+1]===1&&c[s+2]===1&&c[s+3]===4&&c[s+4]===32)return c.slice(s+5,s+5+32);return null}_extractEC_pub(c){for(let s=0;s<c.length-67;s++)if(c[s]===161&&c[s+2]===3&&c[s+3]===66&&c[s+4]===0)return c.slice(s+5,s+5+65);return null}async _importECKeyPkcs8Wrap(c){const s=c.length,n=new Uint8Array([48,19,6,7,42,134,72,206,61,2,1,6,8,42,134,72,206,61,3,1,7]),o=new Uint8Array([2,1,0]),a=this._asn1Len(4,s),r=o.length+n.length+a.length+s,t=this._asn1Len(48,r),e=new Uint8Array(t.length+r);let i=0;return e.set(t,i),i+=t.length,e.set(o,i),i+=o.length,e.set(n,i),i+=n.length,e.set(a,i),i+=a.length,e.set(c,i),crypto.subtle.importKey("pkcs8",e.buffer,{name:"ECDSA",namedCurve:"P-256"},!1,["sign"])}_asn1Len(c,s){return s<128?new Uint8Array([c,s]):s<256?new Uint8Array([c,129,s]):new Uint8Array([c,130,s>>8&255,s&255])}async _coinbaseRequest(c,s,n,o=null){const a=await this._coinbaseJWT(c,s,n),r="/api/coinbase-proxy";try{const t=await fetch(r,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jwt:a,method:s,path:n,body:o})});let e;const i=await t.text();try{e=JSON.parse(i)}catch{e={error:i}}if(!t.ok)throw new Error(e.error||e.message||`Coinbase HTTP ${t.status}`);return e}catch(t){throw t.message==="Failed to fetch"||t.name==="TypeError"?new Error("Error de red al conectar con el proxy. Reintenta en unos segundos."):t}}async _hmacSign(c,s){const n=new TextEncoder,o=await crypto.subtle.importKey("raw",n.encode(c),{name:"HMAC",hash:"SHA-256"},!1,["sign"]),a=await crypto.subtle.sign("HMAC",o,n.encode(s));return Array.from(new Uint8Array(a)).map(r=>r.toString(16).padStart(2,"0")).join("")}async _hmacSignB64(c,s,n=!1){const o=new TextEncoder;let a;if(n){const e=atob(c);a=new Uint8Array(e.length);for(let i=0;i<e.length;i++)a[i]=e.charCodeAt(i)}else a=o.encode(c);const r=await crypto.subtle.importKey("raw",a,{name:"HMAC",hash:"SHA-256"},!1,["sign"]),t=await crypto.subtle.sign("HMAC",r,o.encode(s));return btoa(String.fromCharCode(...new Uint8Array(t)))}async _hmacSignSHA512B64(c,s){const n=atob(c),o=new Uint8Array(n.length);for(let e=0;e<n.length;e++)o[e]=n.charCodeAt(e);const a=await crypto.subtle.importKey("raw",o,{name:"HMAC",hash:"SHA-512"},!1,["sign"]),r=typeof s=="string"?new TextEncoder().encode(s):s,t=await crypto.subtle.sign("HMAC",a,r);return btoa(String.fromCharCode(...new Uint8Array(t)))}async _sha256(c){const s=new TextEncoder().encode(c),n=await crypto.subtle.digest("SHA-256",s);return new Uint8Array(n)}async _proxyRequest(c,s,n={},o=null){const a=await fetch("/api/broker-proxy",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({url:c,method:s,headers:n,body:o})}),r=await a.text();let t;try{t=JSON.parse(r)}catch{t={error:r}}if(!a.ok)throw new Error(t.error||t.message||t.msg||`HTTP ${a.status}`);return t}async _bybitRequest(c,s,n,o={}){const a=Date.now().toString(),r="5000";let t="",e="";s==="GET"?t=Object.entries(o).filter(([,g])=>g!=null).map(([g,w])=>`${g}=${w}`).join("&"):e=JSON.stringify(o);const i=`${a}${c.apiKey}${r}${s==="GET"?t:e}`,l=await this._hmacSign(c.apiSecret,i),p=`${k.bybit.baseUrl}${n}${t?"?"+t:""}`,m={"X-BAPI-API-KEY":c.apiKey,"X-BAPI-SIGN":l,"X-BAPI-SIGN-TYPE":"2","X-BAPI-TIMESTAMP":a,"X-BAPI-RECV-WINDOW":r,"Content-Type":"application/json"},d=await this._proxyRequest(p,s,m,s!=="GET"?o:null);if(d.retCode!==0&&d.retCode!==void 0)throw new Error(`Bybit: ${d.retMsg||"Unknown error"} (${d.retCode})`);return d.result||d}async _krakenRequest(c,s,n={}){const o=Date.now().toString(),a=new URLSearchParams({...n,nonce:o}).toString(),r=await this._sha256(o+a),t=new TextEncoder().encode(s),e=new Uint8Array(t.length+r.length);e.set(t,0),e.set(r,t.length);const i=await this._hmacSignSHA512B64(c.apiSecret,e),l=`${k.kraken.baseUrl}${s}`,p={"API-Key":c.apiKey,"API-Sign":i,"Content-Type":"application/x-www-form-urlencoded"},m=await this._proxyRequest(l,"POST",p,a);if(m.error&&m.error.length>0)throw new Error(`Kraken: ${m.error.join(", ")}`);return m.result||m}async _kucoinRequest(c,s,n,o={}){const a=Date.now().toString();let r="",t="";s==="GET"||s==="DELETE"?(t=Object.entries(o).filter(([,g])=>g!=null).map(([g,w])=>`${g}=${w}`).join("&"),t&&(n=`${n}?${t}`)):r=JSON.stringify(o);const e=`${a}${s}${n}${r}`,i=await this._hmacSignB64(c.apiSecret,e),l=await this._hmacSignB64(c.apiSecret,c.passphrase||""),p=`${k.kucoin.baseUrl}${n}`,m={"KC-API-KEY":c.apiKey,"KC-API-SIGN":i,"KC-API-TIMESTAMP":a,"KC-API-PASSPHRASE":l,"KC-API-KEY-VERSION":"2","Content-Type":"application/json"},d=await this._proxyRequest(p,s,m,s!=="GET"&&s!=="DELETE"?o:null);if(d.code&&d.code!=="200000")throw new Error(`KuCoin: ${d.msg||"Unknown error"} (${d.code})`);return d.data||d}async _okxRequest(c,s,n,o={}){const a=new Date().toISOString();let r="",t="";s==="GET"?(t=Object.entries(o).filter(([,d])=>d!=null).map(([d,g])=>`${d}=${g}`).join("&"),t&&(n=`${n}?${t}`)):r=JSON.stringify(o);const e=`${a}${s}${n}${r}`,i=await this._hmacSignB64(c.apiSecret,e),l=`${k.okx.baseUrl}${n}`,p={"OK-ACCESS-KEY":c.apiKey,"OK-ACCESS-SIGN":i,"OK-ACCESS-TIMESTAMP":a,"OK-ACCESS-PASSPHRASE":c.passphrase||"","Content-Type":"application/json"},m=await this._proxyRequest(l,s,p,s!=="GET"?o:null);if(m.code&&m.code!=="0")throw new Error(`OKX: ${m.msg||"Unknown error"} (${m.code})`);return m.data||m}async _bingxRequest(c,s,n,o={}){const a=Date.now().toString(),r={...o,timestamp:a},t=Object.entries(r).sort(([d],[g])=>d.localeCompare(g)).filter(([,d])=>d!=null).map(([d,g])=>`${d}=${encodeURIComponent(g)}`).join("&"),e=await this._hmacSign(c.apiSecret,t),i=`${t}&signature=${e}`,l=`${k.bingx.baseUrl}${n}?${i}`,p={"X-BX-APIKEY":c.apiKey,"Content-Type":"application/json"},m=await this._proxyRequest(l,s,p,s!=="GET"?o:null);if(m.code&&m.code!==0)throw new Error(`BingX: ${m.msg||"Unknown error"} (${m.code})`);return m.data||m}async _bitgetRequest(c,s,n,o={}){const a=Date.now().toString();let r="",t="";s==="GET"?(t=Object.entries(o).filter(([,d])=>d!=null).map(([d,g])=>`${d}=${g}`).join("&"),t&&(n=`${n}?${t}`)):r=JSON.stringify(o);const e=`${a}${s}${n}${r}`,i=await this._hmacSignB64(c.apiSecret,e),l=`${k.bitget.baseUrl}${n}`,p={"ACCESS-KEY":c.apiKey,"ACCESS-SIGN":i,"ACCESS-TIMESTAMP":a,"ACCESS-PASSPHRASE":c.passphrase||"","Content-Type":"application/json",locale:"en-US"},m=await this._proxyRequest(l,s,p,s!=="GET"?o:null);if(m.code&&m.code!=="00000")throw new Error(`Bitget: ${m.msg||"Unknown error"} (${m.code})`);return m.data||m}async _mexcRequest(c,s,n,o={}){const a=Date.now(),r={...o,timestamp:a,recvWindow:5e3},t=Object.entries(r).filter(([,g])=>g!=null).map(([g,w])=>`${g}=${encodeURIComponent(w)}`).join("&"),e=await this._hmacSign(c.apiSecret,t),i=`${t}&signature=${e}`,l=s==="GET"?`${k.mexc.baseUrl}${n}?${i}`:`${k.mexc.baseUrl}${n}`,p={"X-MEXC-APIKEY":c.apiKey,"Content-Type":"application/json"},m=s!=="GET"?i:null,d=await this._proxyRequest(l,s,p,m);if(d.code&&d.code!==0&&d.code!==200)throw new Error(`MEXC: ${d.msg||"Unknown error"} (${d.code})`);return d}async _binanceSignedRequest(c,s,n,o={}){const a=Date.now(),r={...o,timestamp:a,recvWindow:5e3},t=Object.entries(r).filter(([,g])=>g!=null).map(([g,w])=>`${g}=${encodeURIComponent(w)}`).join("&"),e=await this._hmacSign(c.apiSecret,t),i=`${t}&signature=${e}`,l=s==="GET"?`${k.binance.baseUrl}${n}?${i}`:`${k.binance.baseUrl}${n}`,p={method:s,headers:{"X-MBX-APIKEY":c.apiKey,"Content-Type":"application/x-www-form-urlencoded"}};(s==="POST"||s==="DELETE")&&(p.body=i);const m=await fetch(l,p),d=await m.json();if(!m.ok)throw new Error(`Binance ${n}: ${d.msg||m.statusText} (${d.code||m.status})`);return d}async _binancePublicRequest(c,s={}){const n=Object.entries(s).filter(([,r])=>r!==void 0).map(([r,t])=>`${r}=${encodeURIComponent(t)}`).join("&"),o=`${k.binance.baseUrl}${c}${n?"?"+n:""}`,a=await fetch(o);if(!a.ok)throw new Error(`Binance API error: ${a.status}`);return a.json()}async connect(c){var o,a,r,t;const s=await this._decrypt(c),n=k[c.brokerId];if(!n)throw new Error(`Unsupported broker: ${c.brokerId}`);try{switch(c.brokerId){case"binance":{await this._binancePublicRequest("/api/v3/ping");const e=await this._binanceSignedRequest(s,"GET","/api/v3/account");return this.connections.set(c.id,{creds:s,config:n,connected:!0,permissions:e.permissions||[],accountType:e.accountType}),{success:!0,message:`Connected to Binance (${e.accountType})`,permissions:e.permissions}}case"coinbase":{const e=await this._coinbaseRequest(s,"GET","/api/v3/brokerage/accounts?limit=250");return this.connections.set(c.id,{creds:s,config:n,connected:!0,permissions:["read","trade"],accounts:e.accounts||[]}),{success:!0,message:`Connected to Coinbase (${(e.accounts||[]).length} accounts)`,permissions:["read","trade"]}}case"bybit":{const e=await this._bybitRequest(s,"GET","/v5/account/wallet-balance",{accountType:"UNIFIED"}),i=((r=(a=(o=e==null?void 0:e.list)==null?void 0:o[0])==null?void 0:a.coin)==null?void 0:r.length)||0;return this.connections.set(c.id,{creds:s,config:n,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to Bybit (${i} assets)`,permissions:["read","trade"]}}case"kraken":{const e=await this._krakenRequest(s,"/0/private/Balance"),i=Object.keys(e||{}).length;return this.connections.set(c.id,{creds:s,config:n,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to Kraken (${i} assets)`,permissions:["read","trade"]}}case"kucoin":{const e=await this._kucoinRequest(s,"GET","/api/v1/accounts"),i=Array.isArray(e)?e.length:0;return this.connections.set(c.id,{creds:s,config:n,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to KuCoin (${i} accounts)`,permissions:["read","trade"]}}case"okx":{const e=await this._okxRequest(s,"GET","/api/v5/account/balance"),i=Array.isArray(e)&&((t=e[0])!=null&&t.details)?e[0].details.length:0;return this.connections.set(c.id,{creds:s,config:n,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to OKX (${i} assets)`,permissions:["read","trade"]}}case"bingx":{const e=await this._bingxRequest(s,"GET","/openApi/spot/v1/account/balance"),i=Array.isArray(e==null?void 0:e.balances)?e.balances.filter(l=>parseFloat(l.free)>0).length:0;return this.connections.set(c.id,{creds:s,config:n,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to BingX (${i} assets)`,permissions:["read","trade"]}}case"bitget":{const e=await this._bitgetRequest(s,"GET","/api/v2/spot/account/assets"),i=Array.isArray(e)?e.filter(l=>parseFloat(l.available)>0).length:0;return this.connections.set(c.id,{creds:s,config:n,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to Bitget (${i} assets)`,permissions:["read","trade"]}}case"mexc":{const e=await this._mexcRequest(s,"GET","/api/v3/account"),i=Array.isArray(e==null?void 0:e.balances)?e.balances.filter(l=>parseFloat(l.free)>0).length:0;return this.connections.set(c.id,{creds:s,config:n,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to MEXC (${i} assets)`,permissions:["read","trade"]}}default:return await fetch(n.baseUrl),this.connections.set(c.id,{creds:s,config:n,connected:!0,permissions:[]}),{success:!0,message:`Connected to ${n.name}`}}}catch(e){return{success:!1,message:e.message}}}async getBalances(c){var n,o,a;const s=this.connections.get(c);if(!s)throw new Error("Broker not connected");if(s.config.id==="binance")try{return(await this._binanceSignedRequest(s.creds,"GET","/api/v3/account")).balances.filter(t=>parseFloat(t.free)>0||parseFloat(t.locked)>0).map(t=>({asset:t.asset,free:t.free,locked:t.locked,total:(parseFloat(t.free)+parseFloat(t.locked)).toString()}))}catch(r){throw console.error("Binance getBalances error:",r),r}if(s.config.id==="coinbase")try{return((await this._coinbaseRequest(s.creds,"GET","/api/v3/brokerage/accounts?limit=250")).accounts||[]).map(i=>{var l,p,m,d;return{asset:i.currency,free:((l=i.available_balance)==null?void 0:l.value)||"0",locked:((p=i.hold)==null?void 0:p.value)||"0",total:(parseFloat(((m=i.available_balance)==null?void 0:m.value)||0)+parseFloat(((d=i.hold)==null?void 0:d.value)||0)).toString(),name:i.name}}).filter(i=>parseFloat(i.free)>0||parseFloat(i.locked)>0)}catch(r){throw console.error("Coinbase getBalances:",r),r}if(s.config.id==="bybit")try{const r=await this._bybitRequest(s.creds,"GET","/v5/account/wallet-balance",{accountType:"UNIFIED"});return(((o=(n=r==null?void 0:r.list)==null?void 0:n[0])==null?void 0:o.coin)||[]).filter(e=>parseFloat(e.walletBalance)>0).map(e=>({asset:e.coin,free:e.availableToWithdraw||e.walletBalance||"0",locked:(parseFloat(e.walletBalance||0)-parseFloat(e.availableToWithdraw||0)).toString(),total:e.walletBalance||"0"}))}catch(r){throw console.error("Bybit getBalances:",r),r}if(s.config.id==="kraken")try{const r=await this._krakenRequest(s.creds,"/0/private/Balance"),t={XXBT:"BTC",XETH:"ETH",ZUSD:"USD",XXRP:"XRP",XLTC:"LTC",XXLM:"XLM",XDOGE:"DOGE"};return Object.entries(r||{}).filter(([,e])=>parseFloat(e)>0).map(([e,i])=>({asset:t[e]||e.replace(/^[XZ]/,""),free:i,locked:"0",total:i}))}catch(r){throw console.error("Kraken getBalances:",r),r}if(s.config.id==="kucoin")try{const r=await this._kucoinRequest(s.creds,"GET","/api/v1/accounts",{type:"trade"});return(Array.isArray(r)?r:[]).filter(t=>parseFloat(t.balance)>0).map(t=>({asset:t.currency,free:t.available||"0",locked:t.holds||"0",total:t.balance||"0"}))}catch(r){throw console.error("KuCoin getBalances:",r),r}if(s.config.id==="okx")try{const r=await this._okxRequest(s.creds,"GET","/api/v5/account/balance");return(Array.isArray(r)&&((a=r[0])!=null&&a.details)?r[0].details:[]).filter(e=>parseFloat(e.cashBal)>0).map(e=>({asset:e.ccy,free:e.availBal||e.cashBal||"0",locked:e.frozenBal||"0",total:e.cashBal||"0"}))}catch(r){throw console.error("OKX getBalances:",r),r}if(s.config.id==="bingx")try{const r=await this._bingxRequest(s.creds,"GET","/openApi/spot/v1/account/balance");return((r==null?void 0:r.balances)||(Array.isArray(r)?r:[])).filter(e=>parseFloat(e.free||e.available||0)>0).map(e=>({asset:e.asset||e.currency,free:e.free||e.available||"0",locked:e.locked||e.freeze||"0",total:(parseFloat(e.free||e.available||0)+parseFloat(e.locked||e.freeze||0)).toString()}))}catch(r){throw console.error("BingX getBalances:",r),r}if(s.config.id==="bitget")try{const r=await this._bitgetRequest(s.creds,"GET","/api/v2/spot/account/assets");return(Array.isArray(r)?r:[]).filter(e=>parseFloat(e.available||0)>0).map(e=>({asset:e.coin||e.coinName,free:e.available||"0",locked:e.frozen||e.lock||"0",total:(parseFloat(e.available||0)+parseFloat(e.frozen||e.lock||0)).toString()}))}catch(r){throw console.error("Bitget getBalances:",r),r}if(s.config.id==="mexc")try{const r=await this._mexcRequest(s.creds,"GET","/api/v3/account");return(Array.isArray(r==null?void 0:r.balances)?r.balances:[]).filter(e=>parseFloat(e.free||0)>0).map(e=>({asset:e.asset,free:e.free||"0",locked:e.locked||"0",total:(parseFloat(e.free||0)+parseFloat(e.locked||0)).toString()}))}catch(r){throw console.error("MEXC getBalances:",r),r}return[]}async placeOrder(c,s){var p,m,d,g,w,C,E,S,R,L,U,A,F,B,v,j,z;const n=this.connections.get(c);if(!n)throw new Error("Broker not connected");const{symbol:o,side:a,type:r,quantity:t,price:e,stopLoss:i,takeProfit:l}=s;if(!o||!a||!r||!t)throw new Error("Missing required order fields");if(n.config.id==="binance")try{const y={market:"MARKET",limit:"LIMIT",stop_loss:"STOP_LOSS_LIMIT"}[r]||"MARKET",f={symbol:o,side:a.toUpperCase(),type:y,quantity:t.toString()};(y==="LIMIT"||y==="STOP_LOSS_LIMIT")&&(f.timeInForce="GTC",f.price=parseFloat(e).toFixed(2)),y==="STOP_LOSS_LIMIT"&&(f.stopPrice=parseFloat(i||e).toFixed(2));const u=await this._binanceSignedRequest(n.creds,"POST","/api/v3/order",f);return{id:(p=u.orderId)==null?void 0:p.toString(),clientOrderId:u.clientOrderId,symbol:u.symbol,side:(m=u.side)==null?void 0:m.toLowerCase(),type:(d=u.type)==null?void 0:d.toLowerCase(),quantity:parseFloat(u.origQty||t),price:parseFloat(u.price||e||0),filledPrice:parseFloat(((w=(g=u.fills)==null?void 0:g[0])==null?void 0:w.price)||u.price||0),filledQty:parseFloat(u.executedQty||0),status:(C=u.status)==null?void 0:C.toLowerCase(),timestamp:new Date(u.transactTime||Date.now()).toISOString(),broker:"Binance",real:!0,raw:u}}catch(y){throw console.error("Binance placeOrder error:",y),y}if(n.config.id==="coinbase")try{const y=o.replace(/([A-Z]+)(USDT|USDC|USD|BTC|ETH)$/i,"$1-$2").toUpperCase(),f={};r==="market"?a.toLowerCase()==="buy"?f.market_market_ioc={quote_size:(parseFloat(t)*parseFloat(e||0)).toFixed(2)}:f.market_market_ioc={base_size:parseFloat(t).toString()}:r==="limit"&&(f.limit_limit_gtc={base_size:parseFloat(t).toString(),limit_price:parseFloat(e).toFixed(2)});const u={client_order_id:crypto.randomUUID(),product_id:y,side:a.toUpperCase(),order_configuration:f},h=await this._coinbaseRequest(n.creds,"POST","/api/v3/brokerage/orders",u);if(!h.success){const b=((E=h.error_response)==null?void 0:E.error)||((S=h.failure_response)==null?void 0:S.error)||((R=h.error_response)==null?void 0:R.message)||h.error||"Unknown error",T=((L=h.error_response)==null?void 0:L.error_details)||((U=h.failure_response)==null?void 0:U.message)||"";throw console.error("[COINBASE ORDER] FAILED:",b,T),new Error(`Coinbase order failed: ${b}${T?" — "+T:""}`)}const P=h.success_response||h,D=P.order_id||P.id;if(!D)throw console.error("[COINBASE ORDER] No order_id in response:",h),new Error("Coinbase: no order_id returned");let I=0,_=0,O="unknown";for(let b=0;b<3;b++)try{b>0&&await new Promise(ne=>setTimeout(ne,500));const T=await this._coinbaseRequest(n.creds,"GET",`/api/v3/brokerage/orders/historical/${D}`),M=T.order||T;if(O=(M.status||"").toUpperCase(),I=parseFloat(M.average_filled_price||0),_=parseFloat(M.filled_size||0),O==="FILLED"||O==="CANCELLED"||_>0)break}catch(T){console.warn(`[COINBASE ORDER] Detail fetch attempt ${b+1} failed:`,T.message)}return _===0&&I===0&&(console.warn("[COINBASE ORDER] Could not confirm fill for",D,"- status:",O),I=parseFloat(e||0),_=parseFloat(t),O="UNCONFIRMED"),{id:D,clientOrderId:u.client_order_id,symbol:y,side:a.toLowerCase(),type:r,quantity:_,price:I,filledPrice:I,filledQty:_,status:O.toLowerCase(),confirmed:O!=="UNCONFIRMED",timestamp:new Date().toISOString(),broker:"Coinbase",real:!0}}catch(y){throw console.error("[COINBASE ORDER] placeOrder error:",y.message),y}if(n.config.id==="bybit")try{const y=o.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase(),f={category:"spot",symbol:y,side:a.charAt(0).toUpperCase()+a.slice(1).toLowerCase(),orderType:r==="market"?"Market":"Limit",qty:t.toString()};r==="market"&&a.toLowerCase()==="buy"&&(f.marketUnit="quoteCoin",f.qty=(parseFloat(t)*parseFloat(e||0)).toFixed(2)),r==="limit"&&(f.price=parseFloat(e).toFixed(2),f.timeInForce="GTC");const h=(await this._bybitRequest(n.creds,"POST","/v5/order/create",f)).orderId||Date.now().toString(36);let P=parseFloat(e||0),D=parseFloat(t);try{await new Promise(O=>setTimeout(O,500));const I=await this._bybitRequest(n.creds,"GET","/v5/order/realtime",{category:"spot",orderId:h}),_=(A=I==null?void 0:I.list)==null?void 0:A[0];_&&(P=parseFloat(_.avgPrice||_.price||e||0),D=parseFloat(_.cumExecQty||t))}catch{}return{id:h,symbol:y,side:a.toLowerCase(),type:r,quantity:D,price:P,filledPrice:P,filledQty:D,status:"filled",timestamp:new Date().toISOString(),broker:"Bybit",real:!0}}catch(y){throw console.error("Bybit placeOrder:",y),y}if(n.config.id==="kraken")try{const y=o.replace("BTC","XBT"),f={pair:y,type:a.toLowerCase(),ordertype:r==="market"?"market":"limit",volume:t.toString()};r==="limit"&&(f.price=parseFloat(e).toFixed(2));const u=await this._krakenRequest(n.creds,"/0/private/AddOrder",f);return{id:((F=u==null?void 0:u.txid)==null?void 0:F[0])||Date.now().toString(36),symbol:y,side:a.toLowerCase(),type:r,quantity:parseFloat(t),price:parseFloat(e||0),filledPrice:parseFloat(e||0),filledQty:parseFloat(t),status:"filled",timestamp:new Date().toISOString(),broker:"Kraken",real:!0}}catch(y){throw console.error("Kraken placeOrder:",y),y}if(n.config.id==="kucoin")try{const y=o.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase(),f={clientOid:crypto.randomUUID(),symbol:y,side:a.toLowerCase(),type:r==="market"?"market":"limit"};r==="market"?a.toLowerCase()==="buy"?f.funds=(parseFloat(t)*parseFloat(e||0)).toFixed(2):f.size=t.toString():(f.price=parseFloat(e).toFixed(2),f.size=t.toString());const u=await this._kucoinRequest(n.creds,"POST","/api/v1/orders",f);return{id:(u==null?void 0:u.orderId)||Date.now().toString(36),symbol:y,side:a.toLowerCase(),type:r,quantity:parseFloat(t),price:parseFloat(e||0),filledPrice:parseFloat(e||0),filledQty:parseFloat(t),status:"filled",timestamp:new Date().toISOString(),broker:"KuCoin",real:!0}}catch(y){throw console.error("KuCoin placeOrder:",y),y}if(n.config.id==="okx")try{const y=o.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase(),f={instId:y,tdMode:"cash",side:a.toLowerCase(),ordType:r==="market"?"market":"limit",sz:t.toString()};r==="market"&&a.toLowerCase()==="buy"&&(f.tgtCcy="quote_ccy",f.sz=(parseFloat(t)*parseFloat(e||0)).toFixed(2)),r==="limit"&&(f.px=parseFloat(e).toFixed(2));const u=await this._okxRequest(n.creds,"POST","/api/v5/trade/order",f),h=Array.isArray(u)?(B=u[0])==null?void 0:B.ordId:(u==null?void 0:u.ordId)||Date.now().toString(36);if(Array.isArray(u)&&((v=u[0])==null?void 0:v.sCode)!=="0")throw new Error(`OKX order failed: ${(j=u[0])==null?void 0:j.sMsg}`);return{id:h,symbol:y,side:a.toLowerCase(),type:r,quantity:parseFloat(t),price:parseFloat(e||0),filledPrice:parseFloat(e||0),filledQty:parseFloat(t),status:"filled",timestamp:new Date().toISOString(),broker:"OKX",real:!0}}catch(y){throw console.error("OKX placeOrder:",y),y}if(n.config.id==="bingx")try{const y=o.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase(),f={symbol:y,side:a.toUpperCase(),type:r==="market"?"MARKET":"LIMIT"};r==="market"?a.toLowerCase()==="buy"?f.quoteOrderQty=(parseFloat(t)*parseFloat(e||0)).toFixed(2):f.quantity=parseFloat(t).toString():(f.price=parseFloat(e).toFixed(2),f.quantity=parseFloat(t).toString());const u=await this._bingxRequest(n.creds,"POST","/openApi/spot/v1/trade/order",f),h=(u==null?void 0:u.orderId)||((z=u==null?void 0:u.data)==null?void 0:z.orderId)||Date.now().toString(36);return{id:h==null?void 0:h.toString(),symbol:y,side:a.toLowerCase(),type:r,quantity:parseFloat(t),price:parseFloat(e||0),filledPrice:parseFloat((u==null?void 0:u.price)||e||0),filledQty:parseFloat((u==null?void 0:u.executedQty)||t),status:"filled",timestamp:new Date().toISOString(),broker:"BingX",real:!0}}catch(y){throw console.error("BingX placeOrder:",y),y}if(n.config.id==="bitget")try{const y=o.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase(),f={symbol:y,side:a.toLowerCase(),orderType:r==="market"?"market":"limit",force:"gtc",size:t.toString()};r==="market"&&a.toLowerCase()==="buy"&&(f.size=(parseFloat(t)*parseFloat(e||0)).toFixed(2)),r==="limit"&&(f.price=parseFloat(e).toFixed(2));const u=await this._bitgetRequest(n.creds,"POST","/api/v2/spot/trade/place-order",f),h=(u==null?void 0:u.orderId)||Date.now().toString(36);return{id:h==null?void 0:h.toString(),symbol:y,side:a.toLowerCase(),type:r,quantity:parseFloat(t),price:parseFloat(e||0),filledPrice:parseFloat(e||0),filledQty:parseFloat(t),status:"filled",timestamp:new Date().toISOString(),broker:"Bitget",real:!0}}catch(y){throw console.error("Bitget placeOrder:",y),y}if(n.config.id==="mexc")try{const y=o.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase(),f={symbol:y,side:a.toUpperCase(),type:r==="market"?"MARKET":"LIMIT"};r==="market"?a.toLowerCase()==="buy"?f.quoteOrderQty=(parseFloat(t)*parseFloat(e||0)).toFixed(2):f.quantity=parseFloat(t).toString():(f.price=parseFloat(e).toFixed(2),f.quantity=parseFloat(t).toString(),f.timeInForce="GTC");const u=await this._mexcRequest(n.creds,"POST","/api/v3/order",f),h=(u==null?void 0:u.orderId)||Date.now().toString(36);return{id:h==null?void 0:h.toString(),symbol:y,side:a.toLowerCase(),type:r,quantity:parseFloat(t),price:parseFloat(e||0),filledPrice:parseFloat((u==null?void 0:u.price)||e||0),filledQty:parseFloat((u==null?void 0:u.executedQty)||t),status:"filled",timestamp:new Date().toISOString(),broker:"MEXC",real:!0}}catch(y){throw console.error("MEXC placeOrder:",y),y}if(n.config.id==="wallet")try{const y=n.chainId||56,f=n.creds.apiSecret,u=await ge.placeOrder(f,y,{symbol:o,side:a,type:"market",quantity:t,price:e});if(!u.success)throw new Error(u.error||"DEX swap failed");return{id:u.txHash||Date.now().toString(36),symbol:u.symbol||o,side:a.toLowerCase(),type:"market",quantity:parseFloat(u.amountIn||t),price:parseFloat(u.effectivePrice||e||0),filledPrice:parseFloat(u.effectivePrice||e||0),filledQty:parseFloat(u.amountOut||t),status:"filled",timestamp:new Date().toISOString(),broker:u.mode==="aggregator"?"Kairos Exchange":"Kairos Wallet",real:!0,txHash:u.txHash,chain:u.chain,dex:u.dex,mode:u.mode,sources:u.sources,sourceSummary:u.sourceSummary}}catch(y){throw console.error("Wallet DEX placeOrder:",y),y}return{id:Date.now().toString(36),symbol:o,side:a,type:r,quantity:parseFloat(t),price:e?parseFloat(e):null,status:r==="market"?"filled":"new",filledPrice:r==="market"?parseFloat(e||0):null,timestamp:new Date().toISOString(),broker:n.config.name,simulated:!0}}async placeLeveragedOrder(c,s){var w;this.connections.get(c);const{symbol:n,side:o,quantity:a,price:r,leverage:t,action:e,positionId:i,stopLoss:l,takeProfit:p,execRoute:m}=s,d=(w=J.getState().user)==null?void 0:w.walletAddress;if(!d)throw new Error("Wallet address required for leveraged trading");const g=m==="dex"?`${ie}/api/perps`:`${ie}/api/margin`;if(e==="close"&&i)try{const C=await fetch(`${g}/close`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({wallet:d,positionId:i})}),E=await C.json();if(!C.ok||E.error)throw new Error(E.error||"Close position failed");const S=E.data||E;return{id:i,symbol:n,side:o.toLowerCase(),type:"market",quantity:parseFloat(S.collateral||a),price:parseFloat(S.exitPrice||r||0),filledPrice:parseFloat(S.exitPrice||r||0),filledQty:parseFloat(S.positionSize||a),profit:parseFloat(S.realizedPnl||S.pnl||0),status:"filled",timestamp:new Date().toISOString(),broker:"Kairos Perps",real:!0,leveraged:!0,leverage:t,action:"close"}}catch(C){throw console.error("[LEVERAGED] Close error:",C.message),C}try{const C=o.toLowerCase()==="buy"?"LONG":"SHORT",E=parseFloat(a)*parseFloat(r||1);let S=n;const R=n.match(/^([A-Z]+)(KAIROS|USDT|USDC|USD)$/i);R&&(S=`${R[1]}/${R[2]==="KAIROS"?"KAIROS":"USD"}`);const L=await fetch(`${g}/open`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({wallet:d,pair:S,side:C,leverage:parseInt(t)||3,collateral:E,stopLoss:l||void 0,takeProfit:p||void 0})}),U=await L.json();if(!L.ok||U.error)throw new Error(U.error||"Open position failed");const A=U.data||U;return{id:A.id||A.positionId||Date.now().toString(36),symbol:n,side:o.toLowerCase(),type:"market",quantity:parseFloat(A.collateral||E),price:parseFloat(A.entryPrice||r||0),filledPrice:parseFloat(A.entryPrice||r||0),filledQty:parseFloat(A.positionSize||E*t),status:"filled",timestamp:new Date().toISOString(),broker:"Kairos Perps",real:!0,leveraged:!0,leverage:parseInt(t),positionId:A.id||A.positionId,liquidationPrice:A.liquidationPrice,marginRatio:A.marginRatio,action:"open"}}catch(C){throw console.error("[LEVERAGED] Open error:",C.message),C}}async closeLeveragedPosition(c,{positionId:s,symbol:n,side:o,price:a,leverage:r}){return this.placeLeveragedOrder(c,{symbol:n,side:o==="buy"?"sell":"buy",quantity:0,price:a,leverage:r,action:"close",positionId:s})}async cancelOrder(c,s,n){const o=this.connections.get(c);if(!o)throw new Error("Broker not connected");if(o.config.id==="binance")try{const a=await this._binanceSignedRequest(o.creds,"DELETE","/api/v3/order",{symbol:n,orderId:s});return{success:!0,orderId:a.orderId,status:a.status}}catch(a){return{success:!1,message:a.message}}if(o.config.id==="coinbase")try{return await this._coinbaseRequest(o.creds,"POST","/api/v3/brokerage/orders/batch_cancel",{order_ids:[s]}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(o.config.id==="bybit")try{return await this._bybitRequest(o.creds,"POST","/v5/order/cancel",{category:"spot",symbol:n,orderId:s}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(o.config.id==="kraken")try{return await this._krakenRequest(o.creds,"/0/private/CancelOrder",{txid:s}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(o.config.id==="kucoin")try{return await this._kucoinRequest(o.creds,"DELETE",`/api/v1/orders/${s}`),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(o.config.id==="okx")try{return await this._okxRequest(o.creds,"POST","/api/v5/trade/cancel-order",{instId:n,ordId:s}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(o.config.id==="bingx")try{return await this._bingxRequest(o.creds,"POST","/openApi/spot/v1/trade/cancel",{symbol:n,orderId:s}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(o.config.id==="bitget")try{return await this._bitgetRequest(o.creds,"POST","/api/v2/spot/trade/cancel-order",{symbol:n,orderId:s}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(o.config.id==="mexc")try{return await this._mexcRequest(o.creds,"DELETE","/api/v3/order",{symbol:n,orderId:s}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}return o.config.id==="wallet"?{success:!1,message:"DEX orders are instant swaps and cannot be cancelled"}:{success:!0,orderId:s,simulated:!0}}async getOpenOrders(c,s){const n=this.connections.get(c);if(!n)throw new Error("Broker not connected");if(n.config.id==="binance")try{const o=s?{symbol:s}:{};return(await this._binanceSignedRequest(n.creds,"GET","/api/v3/openOrders",o)).map(r=>{var t,e,i,l;return{id:(t=r.orderId)==null?void 0:t.toString(),symbol:r.symbol,side:(e=r.side)==null?void 0:e.toLowerCase(),type:(i=r.type)==null?void 0:i.toLowerCase(),quantity:parseFloat(r.origQty),price:parseFloat(r.price),filledQty:parseFloat(r.executedQty),status:(l=r.status)==null?void 0:l.toLowerCase(),time:new Date(r.time).toISOString()}})}catch{return[]}if(n.config.id==="coinbase")try{const o=s?s.replace(/([A-Z]+)(USDT|USDC|USD|BTC|ETH)$/i,"$1-$2").toUpperCase():void 0;let a="/api/v3/brokerage/orders/historical/batch?order_status=OPEN";return o&&(a+=`&product_id=${o}`),((await this._coinbaseRequest(n.creds,"GET",a)).orders||[]).map(t=>{var e,i,l,p,m,d,g;return{id:t.order_id,symbol:t.product_id,side:(e=t.side)==null?void 0:e.toLowerCase(),type:(i=t.order_type)==null?void 0:i.toLowerCase(),quantity:parseFloat(((p=(l=t.order_configuration)==null?void 0:l.limit_limit_gtc)==null?void 0:p.base_size)||0),price:parseFloat(((d=(m=t.order_configuration)==null?void 0:m.limit_limit_gtc)==null?void 0:d.limit_price)||t.average_filled_price||0),filledQty:parseFloat(t.filled_size||0),status:(g=t.status)==null?void 0:g.toLowerCase(),time:t.created_time}})}catch(o){return console.error("[COINBASE] getOpenOrders error:",o.message),[]}if(n.config.id==="bybit")try{const o={category:"spot"};s&&(o.symbol=s);const a=await this._bybitRequest(n.creds,"GET","/v5/order/realtime",o);return((a==null?void 0:a.list)||[]).map(r=>{var t,e,i;return{id:r.orderId,symbol:r.symbol,side:(t=r.side)==null?void 0:t.toLowerCase(),type:(e=r.orderType)==null?void 0:e.toLowerCase(),quantity:parseFloat(r.qty||0),price:parseFloat(r.price||0),filledQty:parseFloat(r.cumExecQty||0),status:(i=r.orderStatus)==null?void 0:i.toLowerCase(),time:r.createdTime?new Date(parseInt(r.createdTime)).toISOString():null}})}catch(o){return console.error("Bybit getOpenOrders:",o.message),[]}if(n.config.id==="kraken")try{const o=await this._krakenRequest(n.creds,"/0/private/OpenOrders"),a=(o==null?void 0:o.open)||{};return Object.entries(a).map(([r,t])=>{var e,i,l,p,m,d,g;return{id:r,symbol:((e=t.descr)==null?void 0:e.pair)||"",side:(l=(i=t.descr)==null?void 0:i.type)==null?void 0:l.toLowerCase(),type:(m=(p=t.descr)==null?void 0:p.ordertype)==null?void 0:m.toLowerCase(),quantity:parseFloat(t.vol||0),price:parseFloat(((d=t.descr)==null?void 0:d.price)||0),filledQty:parseFloat(t.vol_exec||0),status:((g=t.status)==null?void 0:g.toLowerCase())||"open",time:t.opentm?new Date(t.opentm*1e3).toISOString():null}})}catch(o){return console.error("Kraken getOpenOrders:",o.message),[]}if(n.config.id==="kucoin")try{const o={status:"active"};s&&(o.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const a=await this._kucoinRequest(n.creds,"GET","/api/v1/orders",o);return(Array.isArray(a==null?void 0:a.items)?a.items:Array.isArray(a)?a:[]).map(t=>{var e,i;return{id:t.id,symbol:t.symbol,side:(e=t.side)==null?void 0:e.toLowerCase(),type:(i=t.type)==null?void 0:i.toLowerCase(),quantity:parseFloat(t.size||0),price:parseFloat(t.price||0),filledQty:parseFloat(t.dealSize||0),status:t.isActive?"open":"done",time:t.createdAt?new Date(parseInt(t.createdAt)).toISOString():null}})}catch(o){return console.error("KuCoin getOpenOrders:",o.message),[]}if(n.config.id==="okx")try{const o={instType:"SPOT"};s&&(o.instId=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const a=await this._okxRequest(n.creds,"GET","/api/v5/trade/orders-pending",o);return(Array.isArray(a)?a:[]).map(t=>{var e,i,l;return{id:t.ordId,symbol:t.instId,side:(e=t.side)==null?void 0:e.toLowerCase(),type:(i=t.ordType)==null?void 0:i.toLowerCase(),quantity:parseFloat(t.sz||0),price:parseFloat(t.px||0),filledQty:parseFloat(t.accFillSz||0),status:((l=t.state)==null?void 0:l.toLowerCase())||"open",time:t.cTime?new Date(parseInt(t.cTime)).toISOString():null}})}catch(o){return console.error("OKX getOpenOrders:",o.message),[]}if(n.config.id==="bingx")try{const o={};s&&(o.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const a=await this._bingxRequest(n.creds,"GET","/openApi/spot/v1/trade/openOrders",o);return((a==null?void 0:a.orders)||(Array.isArray(a)?a:[])).map(t=>{var e,i,l,p;return{id:(e=t.orderId)==null?void 0:e.toString(),symbol:t.symbol,side:(i=t.side)==null?void 0:i.toLowerCase(),type:(l=t.type)==null?void 0:l.toLowerCase(),quantity:parseFloat(t.origQty||0),price:parseFloat(t.price||0),filledQty:parseFloat(t.executedQty||0),status:((p=t.status)==null?void 0:p.toLowerCase())||"open",time:t.time?new Date(parseInt(t.time)).toISOString():null}})}catch(o){return console.error("BingX getOpenOrders:",o.message),[]}if(n.config.id==="bitget")try{const o={};s&&(o.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase());const a=await this._bitgetRequest(n.creds,"GET","/api/v2/spot/trade/unfilled-orders",o);return(Array.isArray(a)?a:[]).map(t=>{var e,i,l;return{id:t.orderId,symbol:t.symbol,side:(e=t.side)==null?void 0:e.toLowerCase(),type:(i=t.orderType)==null?void 0:i.toLowerCase(),quantity:parseFloat(t.size||0),price:parseFloat(t.price||0),filledQty:parseFloat(t.baseVolume||0),status:((l=t.status)==null?void 0:l.toLowerCase())||"open",time:t.cTime?new Date(parseInt(t.cTime)).toISOString():null}})}catch(o){return console.error("Bitget getOpenOrders:",o.message),[]}if(n.config.id==="mexc")try{const o={};s&&(o.symbol=s);const a=await this._mexcRequest(n.creds,"GET","/api/v3/openOrders",o);return(Array.isArray(a)?a:[]).map(t=>{var e,i,l,p;return{id:(e=t.orderId)==null?void 0:e.toString(),symbol:t.symbol,side:(i=t.side)==null?void 0:i.toLowerCase(),type:(l=t.type)==null?void 0:l.toLowerCase(),quantity:parseFloat(t.origQty||0),price:parseFloat(t.price||0),filledQty:parseFloat(t.executedQty||0),status:((p=t.status)==null?void 0:p.toLowerCase())||"open",time:t.time?new Date(t.time).toISOString():null}})}catch(o){return console.error("MEXC getOpenOrders:",o.message),[]}return[]}async getClosedOrders(c,s,n=50){const o=this.connections.get(c);if(!o)throw new Error("Broker not connected");const a=(r,t)=>{var e;return{id:((e=r[t.id])==null?void 0:e.toString())||"",symbol:r[t.symbol]||"",side:(r[t.side]||"").toLowerCase(),type:(r[t.type]||"").toLowerCase(),quantity:parseFloat(r[t.qty]||0),price:parseFloat(r[t.price]||0),filledQty:parseFloat(r[t.filledQty]||0),avgPrice:parseFloat(r[t.avgPrice]||r[t.price]||0),status:(r[t.status]||"closed").toLowerCase(),time:t.timeFn?t.timeFn(r):null}};if(o.config.id==="binance")try{const r={limit:n};s&&(r.symbol=s);const t=await this._binanceSignedRequest(o.creds,"GET","/api/v3/allOrders",r);return(Array.isArray(t)?t:[]).filter(i=>i.status!=="NEW"&&i.status!=="PARTIALLY_FILLED").map(i=>a(i,{id:"orderId",symbol:"symbol",side:"side",type:"type",qty:"origQty",price:"price",filledQty:"executedQty",avgPrice:"price",status:"status",timeFn:l=>l.time?new Date(l.time).toISOString():null}))}catch(r){return console.error("Binance getClosedOrders:",r.message),[]}if(o.config.id==="coinbase")try{const r={order_status:["FILLED","CANCELLED","EXPIRED"],limit:n};s&&(r.product_id=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const t=await this._coinbaseRequest(o.creds,"GET","/api/v3/brokerage/orders/historical/batch",r);return((t==null?void 0:t.orders)||[]).map(e=>a(e,{id:"order_id",symbol:"product_id",side:"side",type:"order_type",qty:"base_size",price:"average_filled_price",filledQty:"filled_size",avgPrice:"average_filled_price",status:"status",timeFn:i=>i.created_time||null}))}catch(r){return console.error("Coinbase getClosedOrders:",r.message),[]}if(o.config.id==="bybit")try{const r={category:"spot",limit:n.toString()};s&&(r.symbol=s);const t=await this._bybitRequest(o.creds,"GET","/v5/order/history",r);return((t==null?void 0:t.list)||[]).map(e=>a(e,{id:"orderId",symbol:"symbol",side:"side",type:"orderType",qty:"qty",price:"price",filledQty:"cumExecQty",avgPrice:"avgPrice",status:"orderStatus",timeFn:i=>i.createdTime?new Date(parseInt(i.createdTime)).toISOString():null}))}catch(r){return console.error("Bybit getClosedOrders:",r.message),[]}if(o.config.id==="kraken")try{const r=await this._krakenRequest(o.creds,"/0/private/ClosedOrders"),t=(r==null?void 0:r.closed)||{};return Object.entries(t).slice(0,n).map(([e,i])=>{var l,p,m,d,g;return{id:e,symbol:((l=i.descr)==null?void 0:l.pair)||"",side:(((p=i.descr)==null?void 0:p.type)||"").toLowerCase(),type:(((m=i.descr)==null?void 0:m.ordertype)||"").toLowerCase(),quantity:parseFloat(i.vol||0),price:parseFloat(((d=i.descr)==null?void 0:d.price)||0),filledQty:parseFloat(i.vol_exec||0),avgPrice:parseFloat(i.price||((g=i.descr)==null?void 0:g.price)||0),status:(i.status||"closed").toLowerCase(),time:i.closetm?new Date(i.closetm*1e3).toISOString():null}})}catch(r){return console.error("Kraken getClosedOrders:",r.message),[]}if(o.config.id==="kucoin")try{const r={status:"done"};s&&(r.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const t=await this._kucoinRequest(o.creds,"GET","/api/v1/orders",r);return(Array.isArray(t==null?void 0:t.items)?t.items:Array.isArray(t)?t:[]).slice(0,n).map(i=>a(i,{id:"id",symbol:"symbol",side:"side",type:"type",qty:"size",price:"price",filledQty:"dealSize",avgPrice:"dealFunds",status:"status",timeFn:l=>l.createdAt?new Date(parseInt(l.createdAt)).toISOString():null}))}catch(r){return console.error("KuCoin getClosedOrders:",r.message),[]}if(o.config.id==="okx")try{const r={instType:"SPOT"};s&&(r.instId=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const t=await this._okxRequest(o.creds,"GET","/api/v5/trade/orders-history-archive",r);return(Array.isArray(t)?t:[]).slice(0,n).map(i=>a(i,{id:"ordId",symbol:"instId",side:"side",type:"ordType",qty:"sz",price:"px",filledQty:"accFillSz",avgPrice:"avgPx",status:"state",timeFn:l=>l.cTime?new Date(parseInt(l.cTime)).toISOString():null}))}catch(r){return console.error("OKX getClosedOrders:",r.message),[]}if(o.config.id==="bingx")try{const r={limit:n.toString()};s&&(r.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const t=await this._bingxRequest(o.creds,"GET","/openApi/spot/v1/trade/historyOrders",r);return((t==null?void 0:t.orders)||(Array.isArray(t)?t:[])).map(i=>a(i,{id:"orderId",symbol:"symbol",side:"side",type:"type",qty:"origQty",price:"price",filledQty:"executedQty",avgPrice:"avgPrice",status:"status",timeFn:l=>l.time?new Date(parseInt(l.time)).toISOString():null}))}catch(r){return console.error("BingX getClosedOrders:",r.message),[]}if(o.config.id==="bitget")try{const r={limit:n.toString()};s&&(r.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase());const t=await this._bitgetRequest(o.creds,"GET","/api/v2/spot/trade/history-orders",r);return(Array.isArray(t)?t:[]).map(i=>a(i,{id:"orderId",symbol:"symbol",side:"side",type:"orderType",qty:"size",price:"price",filledQty:"baseVolume",avgPrice:"priceAvg",status:"status",timeFn:l=>l.cTime?new Date(parseInt(l.cTime)).toISOString():null}))}catch(r){return console.error("Bitget getClosedOrders:",r.message),[]}if(o.config.id==="mexc")try{const r={limit:n};s&&(r.symbol=s);const t=await this._mexcRequest(o.creds,"GET","/api/v3/allOrders",r);return(Array.isArray(t)?t:[]).filter(i=>i.status!=="NEW").map(i=>a(i,{id:"orderId",symbol:"symbol",side:"side",type:"type",qty:"origQty",price:"price",filledQty:"executedQty",avgPrice:"price",status:"status",timeFn:l=>l.time?new Date(l.time).toISOString():null}))}catch(r){return console.error("MEXC getClosedOrders:",r.message),[]}return[]}async getTradeHistory(c,s,n=50){const o=this.connections.get(c);if(!o)throw new Error("Broker not connected");if(o.config.id==="binance")try{return(await this._binanceSignedRequest(o.creds,"GET","/api/v3/myTrades",{symbol:s,limit:n})).map(r=>{var t,e;return{id:(t=r.id)==null?void 0:t.toString(),orderId:(e=r.orderId)==null?void 0:e.toString(),symbol:r.symbol,side:r.isBuyer?"buy":"sell",price:parseFloat(r.price),quantity:parseFloat(r.qty),commission:parseFloat(r.commission),commissionAsset:r.commissionAsset,time:new Date(r.time).toISOString(),isMaker:r.isMaker}})}catch{return[]}if(o.config.id==="coinbase")try{const a=s?s.replace(/([A-Z]+)(USDT|USDC|USD|BTC|ETH)$/i,"$1-$2").toUpperCase():void 0;let r=`/api/v3/brokerage/orders/historical/fills?limit=${n}`;return a&&(r+=`&product_id=${a}`),((await this._coinbaseRequest(o.creds,"GET",r)).fills||[]).map(e=>{var i,l,p;return{id:e.trade_id||e.entry_id,orderId:e.order_id,symbol:e.product_id,side:(i=e.side)==null?void 0:i.toLowerCase(),price:parseFloat(e.price||0),quantity:parseFloat(e.size||e.size_in_quote||0),commission:parseFloat(e.commission||0),commissionAsset:((p=(l=e.product_id)==null?void 0:l.split("-"))==null?void 0:p[1])||"USD",time:e.trade_time,isMaker:!1}})}catch(a){return console.error("[COINBASE] getTradeHistory error:",a.message),[]}if(o.config.id==="bybit")try{const a={category:"spot",limit:n.toString()};s&&(a.symbol=s);const r=await this._bybitRequest(o.creds,"GET","/v5/execution/list",a);return((r==null?void 0:r.list)||[]).map(t=>{var e;return{id:t.execId,orderId:t.orderId,symbol:t.symbol,side:(e=t.side)==null?void 0:e.toLowerCase(),price:parseFloat(t.execPrice||0),quantity:parseFloat(t.execQty||0),commission:parseFloat(t.execFee||0),commissionAsset:t.feeCurrency||"",time:t.execTime?new Date(parseInt(t.execTime)).toISOString():null,isMaker:t.isMaker==="true"||t.isMaker===!0}})}catch(a){return console.error("Bybit getTradeHistory:",a.message),[]}if(o.config.id==="kraken")try{const a=await this._krakenRequest(o.creds,"/0/private/TradesHistory"),r=(a==null?void 0:a.trades)||{};return Object.entries(r).slice(0,n).map(([t,e])=>{var i;return{id:t,orderId:e.ordertxid,symbol:e.pair,side:(i=e.type)==null?void 0:i.toLowerCase(),price:parseFloat(e.price||0),quantity:parseFloat(e.vol||0),commission:parseFloat(e.fee||0),commissionAsset:"",time:e.time?new Date(e.time*1e3).toISOString():null,isMaker:e.maker===!0}})}catch(a){return console.error("Kraken getTradeHistory:",a.message),[]}if(o.config.id==="kucoin")try{const a={};s&&(a.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const r=await this._kucoinRequest(o.creds,"GET","/api/v1/fills",a);return(Array.isArray(r==null?void 0:r.items)?r.items:Array.isArray(r)?r:[]).slice(0,n).map(e=>{var i;return{id:e.tradeId||e.id,orderId:e.orderId,symbol:e.symbol,side:(i=e.side)==null?void 0:i.toLowerCase(),price:parseFloat(e.price||0),quantity:parseFloat(e.size||0),commission:parseFloat(e.fee||0),commissionAsset:e.feeCurrency||"",time:e.createdAt?new Date(parseInt(e.createdAt)).toISOString():null,isMaker:e.liquidity==="maker"}})}catch(a){return console.error("KuCoin getTradeHistory:",a.message),[]}if(o.config.id==="okx")try{const a={instType:"SPOT"};s&&(a.instId=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const r=await this._okxRequest(o.creds,"GET","/api/v5/trade/fills-history",a);return(Array.isArray(r)?r:[]).slice(0,n).map(e=>{var i;return{id:e.tradeId||e.billId,orderId:e.ordId,symbol:e.instId,side:(i=e.side)==null?void 0:i.toLowerCase(),price:parseFloat(e.fillPx||0),quantity:parseFloat(e.fillSz||0),commission:Math.abs(parseFloat(e.fee||0)),commissionAsset:e.feeCcy||"",time:e.ts?new Date(parseInt(e.ts)).toISOString():null,isMaker:e.execType==="M"}})}catch(a){return console.error("OKX getTradeHistory:",a.message),[]}if(o.config.id==="bingx")try{const a={limit:n.toString()};s&&(a.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const r=await this._bingxRequest(o.creds,"GET","/openApi/spot/v1/trade/historyOrders",a);return((r==null?void 0:r.orders)||(Array.isArray(r)?r:[])).map(e=>{var i,l,p;return{id:(i=e.orderId)==null?void 0:i.toString(),orderId:(l=e.orderId)==null?void 0:l.toString(),symbol:e.symbol,side:(p=e.side)==null?void 0:p.toLowerCase(),price:parseFloat(e.price||e.avgPrice||0),quantity:parseFloat(e.executedQty||e.origQty||0),commission:parseFloat(e.commission||0),commissionAsset:e.commissionAsset||"",time:e.time?new Date(parseInt(e.time)).toISOString():null,isMaker:!1}})}catch(a){return console.error("BingX getTradeHistory:",a.message),[]}if(o.config.id==="bitget")try{const a={limit:n.toString()};s&&(a.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase());const r=await this._bitgetRequest(o.creds,"GET","/api/v2/spot/trade/fills",a);return(Array.isArray(r)?r:[]).map(e=>{var i;return{id:e.tradeId||e.fillId,orderId:e.orderId,symbol:e.symbol,side:(i=e.side)==null?void 0:i.toLowerCase(),price:parseFloat(e.priceAvg||e.price||0),quantity:parseFloat(e.size||0),commission:parseFloat(e.fees||e.fee||0),commissionAsset:e.feeCcy||"",time:e.cTime?new Date(parseInt(e.cTime)).toISOString():null,isMaker:e.tradeScope==="maker"}})}catch(a){return console.error("Bitget getTradeHistory:",a.message),[]}if(o.config.id==="mexc")try{const a={limit:n};s&&(a.symbol=s);const r=await this._mexcRequest(o.creds,"GET","/api/v3/myTrades",a);return(Array.isArray(r)?r:[]).map(e=>{var i,l;return{id:(i=e.id)==null?void 0:i.toString(),orderId:(l=e.orderId)==null?void 0:l.toString(),symbol:e.symbol,side:e.isBuyer?"buy":"sell",price:parseFloat(e.price||0),quantity:parseFloat(e.qty||0),commission:parseFloat(e.commission||0),commissionAsset:e.commissionAsset||"",time:e.time?new Date(e.time).toISOString():null,isMaker:e.isMaker===!0}})}catch(a){return console.error("MEXC getTradeHistory:",a.message),[]}return[]}async getExchangeInfo(c){var s,n,o,a;try{const t=(s=(await this._binancePublicRequest("/api/v3/exchangeInfo",{symbol:c})).symbols)==null?void 0:s[0];if(!t)return null;const e=(n=t.filters)==null?void 0:n.find(p=>p.filterType==="LOT_SIZE"),i=(o=t.filters)==null?void 0:o.find(p=>p.filterType==="PRICE_FILTER"),l=(a=t.filters)==null?void 0:a.find(p=>p.filterType==="NOTIONAL"||p.filterType==="MIN_NOTIONAL");return{symbol:t.symbol,status:t.status,baseAsset:t.baseAsset,quoteAsset:t.quoteAsset,minQty:e?parseFloat(e.minQty):0,maxQty:e?parseFloat(e.maxQty):1/0,stepSize:e?parseFloat(e.stepSize):0,minPrice:i?parseFloat(i.minPrice):0,tickSize:i?parseFloat(i.tickSize):0,minNotional:l?parseFloat(l.minNotional||l.notional):0}}catch{return null}}isConnected(c){return this.connections.has(c)}getConnection(c){return this.connections.get(c)}disconnect(c){this.connections.delete(c)}}const we=new ye;export{we as b};
//# sourceMappingURL=broker-C1kdbZgA.js.map
