import{B as S}from"./index-GzHEPH3k.js";class M{constructor(){this.connections=new Map}_decrypt(n){return{...n,apiKey:atob(n.apiKey),apiSecret:atob(n.apiSecret),passphrase:n.passphrase?atob(n.passphrase):void 0}}async _coinbaseJWT(n,r,o){const i=n.apiKey,s=n.apiSecret,t={alg:"ES256",kid:i,nonce:crypto.randomUUID(),typ:"JWT"},a=Math.floor(Date.now()/1e3),e=`${r} api.coinbase.com${o}`,c={sub:i,iss:"coinbase-cloud",aud:["cdp_service"],nbf:a,exp:a+120,uri:e},g=_=>btoa(_).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),f=_=>g(JSON.stringify(_)),u=_=>g(String.fromCharCode(...new Uint8Array(_))),p=f(t),m=f(c),h=`${p}.${m}`,A=await this._importECKey(s),x=await crypto.subtle.sign({name:"ECDSA",hash:"SHA-256"},A,new TextEncoder().encode(h));return`${h}.${u(x)}`}async _importECKey(n){const r=n.replace(/-----BEGIN (?:EC )?PRIVATE KEY-----/g,"").replace(/-----END (?:EC )?PRIVATE KEY-----/g,"").replace(/\\n/g,"").replace(/\n/g,"").replace(/\r/g,"").replace(/\s/g,""),o=Uint8Array.from(atob(r),e=>e.charCodeAt(0));if(n.includes("BEGIN PRIVATE KEY")&&!n.includes("EC PRIVATE KEY"))return crypto.subtle.importKey("pkcs8",o.buffer,{name:"ECDSA",namedCurve:"P-256"},!1,["sign"]);const i=this._extractEC_d(o),s=this._extractEC_pub(o);if(!i||i.length!==32)throw new Error(`Clave EC inválida: se esperaban 32 bytes para d, se encontraron ${(i==null?void 0:i.length)||0}`);const t=e=>btoa(String.fromCharCode(...e)).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),a={kty:"EC",crv:"P-256",d:t(i)};if(s&&s.length===65&&s[0]===4)a.x=t(s.slice(1,33)),a.y=t(s.slice(33,65));else return this._importECKeyPkcs8Wrap(o);return crypto.subtle.importKey("jwk",a,{name:"ECDSA",namedCurve:"P-256"},!1,["sign"])}_extractEC_d(n){for(let r=0;r<n.length-34;r++)if(n[r]===2&&n[r+1]===1&&n[r+2]===1&&n[r+3]===4&&n[r+4]===32)return n.slice(r+5,r+5+32);return null}_extractEC_pub(n){for(let r=0;r<n.length-67;r++)if(n[r]===161&&n[r+2]===3&&n[r+3]===66&&n[r+4]===0)return n.slice(r+5,r+5+65);return null}async _importECKeyPkcs8Wrap(n){const r=n.length,o=new Uint8Array([48,19,6,7,42,134,72,206,61,2,1,6,8,42,134,72,206,61,3,1,7]),i=new Uint8Array([2,1,0]),s=this._asn1Len(4,r),t=i.length+o.length+s.length+r,a=this._asn1Len(48,t),e=new Uint8Array(a.length+t);let c=0;return e.set(a,c),c+=a.length,e.set(i,c),c+=i.length,e.set(o,c),c+=o.length,e.set(s,c),c+=s.length,e.set(n,c),crypto.subtle.importKey("pkcs8",e.buffer,{name:"ECDSA",namedCurve:"P-256"},!1,["sign"])}_asn1Len(n,r){return r<128?new Uint8Array([n,r]):r<256?new Uint8Array([n,129,r]):new Uint8Array([n,130,r>>8&255,r&255])}async _coinbaseRequest(n,r,o,i=null){const s=await this._coinbaseJWT(n,r,o),t="/api/coinbase-proxy";try{const a=await fetch(t,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jwt:s,method:r,path:o,body:i})});let e;const c=await a.text();try{e=JSON.parse(c)}catch{e={error:c}}if(!a.ok)throw new Error(e.error||e.message||`Coinbase HTTP ${a.status}`);return e}catch(a){throw a.message==="Failed to fetch"||a.name==="TypeError"?new Error("Error de red al conectar con el proxy. Reintenta en unos segundos."):a}}async _hmacSign(n,r){const o=new TextEncoder,i=await crypto.subtle.importKey("raw",o.encode(n),{name:"HMAC",hash:"SHA-256"},!1,["sign"]),s=await crypto.subtle.sign("HMAC",i,o.encode(r));return Array.from(new Uint8Array(s)).map(t=>t.toString(16).padStart(2,"0")).join("")}async _hmacSignB64(n,r,o=!1){const i=new TextEncoder;let s;if(o){const e=atob(n);s=new Uint8Array(e.length);for(let c=0;c<e.length;c++)s[c]=e.charCodeAt(c)}else s=i.encode(n);const t=await crypto.subtle.importKey("raw",s,{name:"HMAC",hash:"SHA-256"},!1,["sign"]),a=await crypto.subtle.sign("HMAC",t,i.encode(r));return btoa(String.fromCharCode(...new Uint8Array(a)))}async _hmacSignSHA512B64(n,r){const o=atob(n),i=new Uint8Array(o.length);for(let e=0;e<o.length;e++)i[e]=o.charCodeAt(e);const s=await crypto.subtle.importKey("raw",i,{name:"HMAC",hash:"SHA-512"},!1,["sign"]),t=typeof r=="string"?new TextEncoder().encode(r):r,a=await crypto.subtle.sign("HMAC",s,t);return btoa(String.fromCharCode(...new Uint8Array(a)))}async _sha256(n){const r=new TextEncoder().encode(n),o=await crypto.subtle.digest("SHA-256",r);return new Uint8Array(o)}async _proxyRequest(n,r,o={},i=null){const s=await fetch("/api/broker-proxy",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({url:n,method:r,headers:o,body:i})}),t=await s.text();let a;try{a=JSON.parse(t)}catch{a={error:t}}if(!s.ok)throw new Error(a.error||a.message||a.msg||`HTTP ${s.status}`);return a}async _bybitRequest(n,r,o,i={}){const s=Date.now().toString(),t="5000";let a="",e="";r==="GET"?a=Object.entries(i).filter(([,m])=>m!=null).map(([m,h])=>`${m}=${h}`).join("&"):e=JSON.stringify(i);const c=`${s}${n.apiKey}${t}${r==="GET"?a:e}`,g=await this._hmacSign(n.apiSecret,c),f=`${S.bybit.baseUrl}${o}${a?"?"+a:""}`,u={"X-BAPI-API-KEY":n.apiKey,"X-BAPI-SIGN":g,"X-BAPI-SIGN-TYPE":"2","X-BAPI-TIMESTAMP":s,"X-BAPI-RECV-WINDOW":t,"Content-Type":"application/json"},p=await this._proxyRequest(f,r,u,r!=="GET"?i:null);if(p.retCode!==0&&p.retCode!==void 0)throw new Error(`Bybit: ${p.retMsg||"Unknown error"} (${p.retCode})`);return p.result||p}async _krakenRequest(n,r,o={}){const i=Date.now().toString(),s=new URLSearchParams({...o,nonce:i}).toString(),t=await this._sha256(i+s),a=new TextEncoder().encode(r),e=new Uint8Array(a.length+t.length);e.set(a,0),e.set(t,a.length);const c=await this._hmacSignSHA512B64(n.apiSecret,e),g=`${S.kraken.baseUrl}${r}`,f={"API-Key":n.apiKey,"API-Sign":c,"Content-Type":"application/x-www-form-urlencoded"},u=await this._proxyRequest(g,"POST",f,s);if(u.error&&u.error.length>0)throw new Error(`Kraken: ${u.error.join(", ")}`);return u.result||u}async _kucoinRequest(n,r,o,i={}){const s=Date.now().toString();let t="",a="";r==="GET"||r==="DELETE"?(a=Object.entries(i).filter(([,m])=>m!=null).map(([m,h])=>`${m}=${h}`).join("&"),a&&(o=`${o}?${a}`)):t=JSON.stringify(i);const e=`${s}${r}${o}${t}`,c=await this._hmacSignB64(n.apiSecret,e),g=await this._hmacSignB64(n.apiSecret,n.passphrase||""),f=`${S.kucoin.baseUrl}${o}`,u={"KC-API-KEY":n.apiKey,"KC-API-SIGN":c,"KC-API-TIMESTAMP":s,"KC-API-PASSPHRASE":g,"KC-API-KEY-VERSION":"2","Content-Type":"application/json"},p=await this._proxyRequest(f,r,u,r!=="GET"&&r!=="DELETE"?i:null);if(p.code&&p.code!=="200000")throw new Error(`KuCoin: ${p.msg||"Unknown error"} (${p.code})`);return p.data||p}async _okxRequest(n,r,o,i={}){const s=new Date().toISOString();let t="",a="";r==="GET"?(a=Object.entries(i).filter(([,p])=>p!=null).map(([p,m])=>`${p}=${m}`).join("&"),a&&(o=`${o}?${a}`)):t=JSON.stringify(i);const e=`${s}${r}${o}${t}`,c=await this._hmacSignB64(n.apiSecret,e),g=`${S.okx.baseUrl}${o}`,f={"OK-ACCESS-KEY":n.apiKey,"OK-ACCESS-SIGN":c,"OK-ACCESS-TIMESTAMP":s,"OK-ACCESS-PASSPHRASE":n.passphrase||"","Content-Type":"application/json"},u=await this._proxyRequest(g,r,f,r!=="GET"?i:null);if(u.code&&u.code!=="0")throw new Error(`OKX: ${u.msg||"Unknown error"} (${u.code})`);return u.data||u}async _bingxRequest(n,r,o,i={}){const s=Date.now().toString(),t={...i,timestamp:s},a=Object.entries(t).sort(([p],[m])=>p.localeCompare(m)).filter(([,p])=>p!=null).map(([p,m])=>`${p}=${encodeURIComponent(m)}`).join("&"),e=await this._hmacSign(n.apiSecret,a),c=`${a}&signature=${e}`,g=`${S.bingx.baseUrl}${o}?${c}`,f={"X-BX-APIKEY":n.apiKey,"Content-Type":"application/json"},u=await this._proxyRequest(g,r,f,r!=="GET"?i:null);if(u.code&&u.code!==0)throw new Error(`BingX: ${u.msg||"Unknown error"} (${u.code})`);return u.data||u}async _bitgetRequest(n,r,o,i={}){const s=Date.now().toString();let t="",a="";r==="GET"?(a=Object.entries(i).filter(([,p])=>p!=null).map(([p,m])=>`${p}=${m}`).join("&"),a&&(o=`${o}?${a}`)):t=JSON.stringify(i);const e=`${s}${r}${o}${t}`,c=await this._hmacSignB64(n.apiSecret,e),g=`${S.bitget.baseUrl}${o}`,f={"ACCESS-KEY":n.apiKey,"ACCESS-SIGN":c,"ACCESS-TIMESTAMP":s,"ACCESS-PASSPHRASE":n.passphrase||"","Content-Type":"application/json",locale:"en-US"},u=await this._proxyRequest(g,r,f,r!=="GET"?i:null);if(u.code&&u.code!=="00000")throw new Error(`Bitget: ${u.msg||"Unknown error"} (${u.code})`);return u.data||u}async _mexcRequest(n,r,o,i={}){const s=Date.now(),t={...i,timestamp:s,recvWindow:5e3},a=Object.entries(t).filter(([,m])=>m!=null).map(([m,h])=>`${m}=${encodeURIComponent(h)}`).join("&"),e=await this._hmacSign(n.apiSecret,a),c=`${a}&signature=${e}`,g=r==="GET"?`${S.mexc.baseUrl}${o}?${c}`:`${S.mexc.baseUrl}${o}`,f={"X-MEXC-APIKEY":n.apiKey,"Content-Type":"application/json"},u=r!=="GET"?c:null,p=await this._proxyRequest(g,r,f,u);if(p.code&&p.code!==0&&p.code!==200)throw new Error(`MEXC: ${p.msg||"Unknown error"} (${p.code})`);return p}async _binanceSignedRequest(n,r,o,i={}){const s=Date.now(),t={...i,timestamp:s,recvWindow:5e3},a=Object.entries(t).filter(([,m])=>m!=null).map(([m,h])=>`${m}=${encodeURIComponent(h)}`).join("&"),e=await this._hmacSign(n.apiSecret,a),c=`${a}&signature=${e}`,g=r==="GET"?`${S.binance.baseUrl}${o}?${c}`:`${S.binance.baseUrl}${o}`,f={method:r,headers:{"X-MBX-APIKEY":n.apiKey,"Content-Type":"application/x-www-form-urlencoded"}};(r==="POST"||r==="DELETE")&&(f.body=c);const u=await fetch(g,f),p=await u.json();if(!u.ok)throw new Error(`Binance ${o}: ${p.msg||u.statusText} (${p.code||u.status})`);return p}async _binancePublicRequest(n,r={}){const o=Object.entries(r).filter(([,t])=>t!==void 0).map(([t,a])=>`${t}=${encodeURIComponent(a)}`).join("&"),i=`${S.binance.baseUrl}${n}${o?"?"+o:""}`,s=await fetch(i);if(!s.ok)throw new Error(`Binance API error: ${s.status}`);return s.json()}async connect(n){var i,s,t,a;const r=this._decrypt(n),o=S[n.brokerId];if(!o)throw new Error(`Unsupported broker: ${n.brokerId}`);try{switch(n.brokerId){case"binance":{await this._binancePublicRequest("/api/v3/ping");const e=await this._binanceSignedRequest(r,"GET","/api/v3/account");return this.connections.set(n.id,{creds:r,config:o,connected:!0,permissions:e.permissions||[],accountType:e.accountType}),{success:!0,message:`Connected to Binance (${e.accountType})`,permissions:e.permissions}}case"coinbase":{const e=await this._coinbaseRequest(r,"GET","/api/v3/brokerage/accounts?limit=250");return this.connections.set(n.id,{creds:r,config:o,connected:!0,permissions:["read","trade"],accounts:e.accounts||[]}),{success:!0,message:`Connected to Coinbase (${(e.accounts||[]).length} accounts)`,permissions:["read","trade"]}}case"bybit":{const e=await this._bybitRequest(r,"GET","/v5/account/wallet-balance",{accountType:"UNIFIED"}),c=((t=(s=(i=e==null?void 0:e.list)==null?void 0:i[0])==null?void 0:s.coin)==null?void 0:t.length)||0;return this.connections.set(n.id,{creds:r,config:o,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to Bybit (${c} assets)`,permissions:["read","trade"]}}case"kraken":{const e=await this._krakenRequest(r,"/0/private/Balance"),c=Object.keys(e||{}).length;return this.connections.set(n.id,{creds:r,config:o,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to Kraken (${c} assets)`,permissions:["read","trade"]}}case"kucoin":{const e=await this._kucoinRequest(r,"GET","/api/v1/accounts"),c=Array.isArray(e)?e.length:0;return this.connections.set(n.id,{creds:r,config:o,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to KuCoin (${c} accounts)`,permissions:["read","trade"]}}case"okx":{const e=await this._okxRequest(r,"GET","/api/v5/account/balance"),c=Array.isArray(e)&&((a=e[0])!=null&&a.details)?e[0].details.length:0;return this.connections.set(n.id,{creds:r,config:o,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to OKX (${c} assets)`,permissions:["read","trade"]}}case"bingx":{const e=await this._bingxRequest(r,"GET","/openApi/spot/v1/account/balance"),c=Array.isArray(e==null?void 0:e.balances)?e.balances.filter(g=>parseFloat(g.free)>0).length:0;return this.connections.set(n.id,{creds:r,config:o,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to BingX (${c} assets)`,permissions:["read","trade"]}}case"bitget":{const e=await this._bitgetRequest(r,"GET","/api/v2/spot/account/assets"),c=Array.isArray(e)?e.filter(g=>parseFloat(g.available)>0).length:0;return this.connections.set(n.id,{creds:r,config:o,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to Bitget (${c} assets)`,permissions:["read","trade"]}}case"mexc":{const e=await this._mexcRequest(r,"GET","/api/v3/account"),c=Array.isArray(e==null?void 0:e.balances)?e.balances.filter(g=>parseFloat(g.free)>0).length:0;return this.connections.set(n.id,{creds:r,config:o,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to MEXC (${c} assets)`,permissions:["read","trade"]}}default:return await fetch(o.baseUrl),this.connections.set(n.id,{creds:r,config:o,connected:!0,permissions:[]}),{success:!0,message:`Connected to ${o.name}`}}}catch(e){return{success:!1,message:e.message}}}async getBalances(n){var o,i,s;const r=this.connections.get(n);if(!r)throw new Error("Broker not connected");if(r.config.id==="binance")try{return(await this._binanceSignedRequest(r.creds,"GET","/api/v3/account")).balances.filter(a=>parseFloat(a.free)>0||parseFloat(a.locked)>0).map(a=>({asset:a.asset,free:a.free,locked:a.locked,total:(parseFloat(a.free)+parseFloat(a.locked)).toString()}))}catch(t){throw console.error("Binance getBalances error:",t),t}if(r.config.id==="coinbase")try{return((await this._coinbaseRequest(r.creds,"GET","/api/v3/brokerage/accounts?limit=250")).accounts||[]).map(c=>{var g,f,u,p;return{asset:c.currency,free:((g=c.available_balance)==null?void 0:g.value)||"0",locked:((f=c.hold)==null?void 0:f.value)||"0",total:(parseFloat(((u=c.available_balance)==null?void 0:u.value)||0)+parseFloat(((p=c.hold)==null?void 0:p.value)||0)).toString(),name:c.name}}).filter(c=>parseFloat(c.free)>0||parseFloat(c.locked)>0)}catch(t){throw console.error("Coinbase getBalances:",t),t}if(r.config.id==="bybit")try{const t=await this._bybitRequest(r.creds,"GET","/v5/account/wallet-balance",{accountType:"UNIFIED"});return(((i=(o=t==null?void 0:t.list)==null?void 0:o[0])==null?void 0:i.coin)||[]).filter(e=>parseFloat(e.walletBalance)>0).map(e=>({asset:e.coin,free:e.availableToWithdraw||e.walletBalance||"0",locked:(parseFloat(e.walletBalance||0)-parseFloat(e.availableToWithdraw||0)).toString(),total:e.walletBalance||"0"}))}catch(t){throw console.error("Bybit getBalances:",t),t}if(r.config.id==="kraken")try{const t=await this._krakenRequest(r.creds,"/0/private/Balance"),a={XXBT:"BTC",XETH:"ETH",ZUSD:"USD",XXRP:"XRP",XLTC:"LTC",XXLM:"XLM",XDOGE:"DOGE"};return Object.entries(t||{}).filter(([,e])=>parseFloat(e)>0).map(([e,c])=>({asset:a[e]||e.replace(/^[XZ]/,""),free:c,locked:"0",total:c}))}catch(t){throw console.error("Kraken getBalances:",t),t}if(r.config.id==="kucoin")try{const t=await this._kucoinRequest(r.creds,"GET","/api/v1/accounts",{type:"trade"});return(Array.isArray(t)?t:[]).filter(a=>parseFloat(a.balance)>0).map(a=>({asset:a.currency,free:a.available||"0",locked:a.holds||"0",total:a.balance||"0"}))}catch(t){throw console.error("KuCoin getBalances:",t),t}if(r.config.id==="okx")try{const t=await this._okxRequest(r.creds,"GET","/api/v5/account/balance");return(Array.isArray(t)&&((s=t[0])!=null&&s.details)?t[0].details:[]).filter(e=>parseFloat(e.cashBal)>0).map(e=>({asset:e.ccy,free:e.availBal||e.cashBal||"0",locked:e.frozenBal||"0",total:e.cashBal||"0"}))}catch(t){throw console.error("OKX getBalances:",t),t}if(r.config.id==="bingx")try{const t=await this._bingxRequest(r.creds,"GET","/openApi/spot/v1/account/balance");return((t==null?void 0:t.balances)||(Array.isArray(t)?t:[])).filter(e=>parseFloat(e.free||e.available||0)>0).map(e=>({asset:e.asset||e.currency,free:e.free||e.available||"0",locked:e.locked||e.freeze||"0",total:(parseFloat(e.free||e.available||0)+parseFloat(e.locked||e.freeze||0)).toString()}))}catch(t){throw console.error("BingX getBalances:",t),t}if(r.config.id==="bitget")try{const t=await this._bitgetRequest(r.creds,"GET","/api/v2/spot/account/assets");return(Array.isArray(t)?t:[]).filter(e=>parseFloat(e.available||0)>0).map(e=>({asset:e.coin||e.coinName,free:e.available||"0",locked:e.frozen||e.lock||"0",total:(parseFloat(e.available||0)+parseFloat(e.frozen||e.lock||0)).toString()}))}catch(t){throw console.error("Bitget getBalances:",t),t}if(r.config.id==="mexc")try{const t=await this._mexcRequest(r.creds,"GET","/api/v3/account");return(Array.isArray(t==null?void 0:t.balances)?t.balances:[]).filter(e=>parseFloat(e.free||0)>0).map(e=>({asset:e.asset,free:e.free||"0",locked:e.locked||"0",total:(parseFloat(e.free||0)+parseFloat(e.locked||0)).toString()}))}catch(t){throw console.error("MEXC getBalances:",t),t}return[]}async placeOrder(n,r){var f,u,p,m,h,A,x,_,O,q,R,D,U,P,B,v,K;const o=this.connections.get(n);if(!o)throw new Error("Broker not connected");const{symbol:i,side:s,type:t,quantity:a,price:e,stopLoss:c,takeProfit:g}=r;if(!i||!s||!t||!a)throw new Error("Missing required order fields");if(o.config.id==="binance")try{const d={market:"MARKET",limit:"LIMIT",stop_loss:"STOP_LOSS_LIMIT"}[t]||"MARKET",y={symbol:i,side:s.toUpperCase(),type:d,quantity:a.toString()};(d==="LIMIT"||d==="STOP_LOSS_LIMIT")&&(y.timeInForce="GTC",y.price=parseFloat(e).toFixed(2)),d==="STOP_LOSS_LIMIT"&&(y.stopPrice=parseFloat(c||e).toFixed(2));const l=await this._binanceSignedRequest(o.creds,"POST","/api/v3/order",y);return{id:(f=l.orderId)==null?void 0:f.toString(),clientOrderId:l.clientOrderId,symbol:l.symbol,side:(u=l.side)==null?void 0:u.toLowerCase(),type:(p=l.type)==null?void 0:p.toLowerCase(),quantity:parseFloat(l.origQty||a),price:parseFloat(l.price||e||0),filledPrice:parseFloat(((h=(m=l.fills)==null?void 0:m[0])==null?void 0:h.price)||l.price||0),filledQty:parseFloat(l.executedQty||0),status:(A=l.status)==null?void 0:A.toLowerCase(),timestamp:new Date(l.transactTime||Date.now()).toISOString(),broker:"Binance",real:!0,raw:l}}catch(d){throw console.error("Binance placeOrder error:",d),d}if(o.config.id==="coinbase")try{const d=i.replace(/([A-Z]+)(USDT|USDC|USD|BTC|ETH)$/i,"$1-$2").toUpperCase(),y={};t==="market"?s.toLowerCase()==="buy"?y.market_market_ioc={quote_size:(parseFloat(a)*parseFloat(e||0)).toFixed(2)}:y.market_market_ioc={base_size:parseFloat(a).toString()}:t==="limit"&&(y.limit_limit_gtc={base_size:parseFloat(a).toString(),limit_price:parseFloat(e).toFixed(2)});const l={client_order_id:crypto.randomUUID(),product_id:d,side:s.toUpperCase(),order_configuration:y},w=await this._coinbaseRequest(o.creds,"POST","/api/v3/brokerage/orders",l);if(!w.success){const F=((x=w.error_response)==null?void 0:x.error)||((_=w.failure_response)==null?void 0:_.error)||((O=w.error_response)==null?void 0:O.message)||w.error||"Unknown error",k=((q=w.error_response)==null?void 0:q.error_details)||((R=w.failure_response)==null?void 0:R.message)||"";throw console.error("[COINBASE ORDER] FAILED:",F,k),new Error(`Coinbase order failed: ${F}${k?" — "+k:""}`)}const $=w.success_response||w,T=$.order_id||$.id;if(!T)throw console.error("[COINBASE ORDER] No order_id in response:",w),new Error("Coinbase: no order_id returned");let C=0,b=0,E="unknown";for(let F=0;F<3;F++)try{F>0&&await new Promise(L=>setTimeout(L,500));const k=await this._coinbaseRequest(o.creds,"GET",`/api/v3/brokerage/orders/historical/${T}`),I=k.order||k;if(E=(I.status||"").toUpperCase(),C=parseFloat(I.average_filled_price||0),b=parseFloat(I.filled_size||0),E==="FILLED"||E==="CANCELLED"||b>0)break}catch(k){console.warn(`[COINBASE ORDER] Detail fetch attempt ${F+1} failed:`,k.message)}return b===0&&C===0&&(console.warn("[COINBASE ORDER] Could not confirm fill for",T,"- status:",E),C=parseFloat(e||0),b=parseFloat(a),E="UNCONFIRMED"),{id:T,clientOrderId:l.client_order_id,symbol:d,side:s.toLowerCase(),type:t,quantity:b,price:C,filledPrice:C,filledQty:b,status:E.toLowerCase(),confirmed:E!=="UNCONFIRMED",timestamp:new Date().toISOString(),broker:"Coinbase",real:!0}}catch(d){throw console.error("[COINBASE ORDER] placeOrder error:",d.message),d}if(o.config.id==="bybit")try{const d=i.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase(),y={category:"spot",symbol:d,side:s.charAt(0).toUpperCase()+s.slice(1).toLowerCase(),orderType:t==="market"?"Market":"Limit",qty:a.toString()};t==="market"&&s.toLowerCase()==="buy"&&(y.marketUnit="quoteCoin",y.qty=(parseFloat(a)*parseFloat(e||0)).toFixed(2)),t==="limit"&&(y.price=parseFloat(e).toFixed(2),y.timeInForce="GTC");const w=(await this._bybitRequest(o.creds,"POST","/v5/order/create",y)).orderId||Date.now().toString(36);let $=parseFloat(e||0),T=parseFloat(a);try{await new Promise(E=>setTimeout(E,500));const C=await this._bybitRequest(o.creds,"GET","/v5/order/realtime",{category:"spot",orderId:w}),b=(D=C==null?void 0:C.list)==null?void 0:D[0];b&&($=parseFloat(b.avgPrice||b.price||e||0),T=parseFloat(b.cumExecQty||a))}catch{}return{id:w,symbol:d,side:s.toLowerCase(),type:t,quantity:T,price:$,filledPrice:$,filledQty:T,status:"filled",timestamp:new Date().toISOString(),broker:"Bybit",real:!0}}catch(d){throw console.error("Bybit placeOrder:",d),d}if(o.config.id==="kraken")try{const d=i.replace("BTC","XBT"),y={pair:d,type:s.toLowerCase(),ordertype:t==="market"?"market":"limit",volume:a.toString()};t==="limit"&&(y.price=parseFloat(e).toFixed(2));const l=await this._krakenRequest(o.creds,"/0/private/AddOrder",y);return{id:((U=l==null?void 0:l.txid)==null?void 0:U[0])||Date.now().toString(36),symbol:d,side:s.toLowerCase(),type:t,quantity:parseFloat(a),price:parseFloat(e||0),filledPrice:parseFloat(e||0),filledQty:parseFloat(a),status:"filled",timestamp:new Date().toISOString(),broker:"Kraken",real:!0}}catch(d){throw console.error("Kraken placeOrder:",d),d}if(o.config.id==="kucoin")try{const d=i.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase(),y={clientOid:crypto.randomUUID(),symbol:d,side:s.toLowerCase(),type:t==="market"?"market":"limit"};t==="market"?s.toLowerCase()==="buy"?y.funds=(parseFloat(a)*parseFloat(e||0)).toFixed(2):y.size=a.toString():(y.price=parseFloat(e).toFixed(2),y.size=a.toString());const l=await this._kucoinRequest(o.creds,"POST","/api/v1/orders",y);return{id:(l==null?void 0:l.orderId)||Date.now().toString(36),symbol:d,side:s.toLowerCase(),type:t,quantity:parseFloat(a),price:parseFloat(e||0),filledPrice:parseFloat(e||0),filledQty:parseFloat(a),status:"filled",timestamp:new Date().toISOString(),broker:"KuCoin",real:!0}}catch(d){throw console.error("KuCoin placeOrder:",d),d}if(o.config.id==="okx")try{const d=i.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase(),y={instId:d,tdMode:"cash",side:s.toLowerCase(),ordType:t==="market"?"market":"limit",sz:a.toString()};t==="market"&&s.toLowerCase()==="buy"&&(y.tgtCcy="quote_ccy",y.sz=(parseFloat(a)*parseFloat(e||0)).toFixed(2)),t==="limit"&&(y.px=parseFloat(e).toFixed(2));const l=await this._okxRequest(o.creds,"POST","/api/v5/trade/order",y),w=Array.isArray(l)?(P=l[0])==null?void 0:P.ordId:(l==null?void 0:l.ordId)||Date.now().toString(36);if(Array.isArray(l)&&((B=l[0])==null?void 0:B.sCode)!=="0")throw new Error(`OKX order failed: ${(v=l[0])==null?void 0:v.sMsg}`);return{id:w,symbol:d,side:s.toLowerCase(),type:t,quantity:parseFloat(a),price:parseFloat(e||0),filledPrice:parseFloat(e||0),filledQty:parseFloat(a),status:"filled",timestamp:new Date().toISOString(),broker:"OKX",real:!0}}catch(d){throw console.error("OKX placeOrder:",d),d}if(o.config.id==="bingx")try{const d=i.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase(),y={symbol:d,side:s.toUpperCase(),type:t==="market"?"MARKET":"LIMIT"};t==="market"?s.toLowerCase()==="buy"?y.quoteOrderQty=(parseFloat(a)*parseFloat(e||0)).toFixed(2):y.quantity=parseFloat(a).toString():(y.price=parseFloat(e).toFixed(2),y.quantity=parseFloat(a).toString());const l=await this._bingxRequest(o.creds,"POST","/openApi/spot/v1/trade/order",y),w=(l==null?void 0:l.orderId)||((K=l==null?void 0:l.data)==null?void 0:K.orderId)||Date.now().toString(36);return{id:w==null?void 0:w.toString(),symbol:d,side:s.toLowerCase(),type:t,quantity:parseFloat(a),price:parseFloat(e||0),filledPrice:parseFloat((l==null?void 0:l.price)||e||0),filledQty:parseFloat((l==null?void 0:l.executedQty)||a),status:"filled",timestamp:new Date().toISOString(),broker:"BingX",real:!0}}catch(d){throw console.error("BingX placeOrder:",d),d}if(o.config.id==="bitget")try{const d=i.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase(),y={symbol:d,side:s.toLowerCase(),orderType:t==="market"?"market":"limit",force:"gtc",size:a.toString()};t==="market"&&s.toLowerCase()==="buy"&&(y.size=(parseFloat(a)*parseFloat(e||0)).toFixed(2)),t==="limit"&&(y.price=parseFloat(e).toFixed(2));const l=await this._bitgetRequest(o.creds,"POST","/api/v2/spot/trade/place-order",y),w=(l==null?void 0:l.orderId)||Date.now().toString(36);return{id:w==null?void 0:w.toString(),symbol:d,side:s.toLowerCase(),type:t,quantity:parseFloat(a),price:parseFloat(e||0),filledPrice:parseFloat(e||0),filledQty:parseFloat(a),status:"filled",timestamp:new Date().toISOString(),broker:"Bitget",real:!0}}catch(d){throw console.error("Bitget placeOrder:",d),d}if(o.config.id==="mexc")try{const d=i.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase(),y={symbol:d,side:s.toUpperCase(),type:t==="market"?"MARKET":"LIMIT"};t==="market"?s.toLowerCase()==="buy"?y.quoteOrderQty=(parseFloat(a)*parseFloat(e||0)).toFixed(2):y.quantity=parseFloat(a).toString():(y.price=parseFloat(e).toFixed(2),y.quantity=parseFloat(a).toString(),y.timeInForce="GTC");const l=await this._mexcRequest(o.creds,"POST","/api/v3/order",y),w=(l==null?void 0:l.orderId)||Date.now().toString(36);return{id:w==null?void 0:w.toString(),symbol:d,side:s.toLowerCase(),type:t,quantity:parseFloat(a),price:parseFloat(e||0),filledPrice:parseFloat((l==null?void 0:l.price)||e||0),filledQty:parseFloat((l==null?void 0:l.executedQty)||a),status:"filled",timestamp:new Date().toISOString(),broker:"MEXC",real:!0}}catch(d){throw console.error("MEXC placeOrder:",d),d}if(o.config.id==="wallet")try{const d=o.chainId||56,y=o.creds.apiSecret,l=await walletBroker.placeOrder(y,d,{symbol:i,side:s,type:"market",quantity:a,price:e});if(!l.success)throw new Error(l.error||"DEX swap failed");return{id:l.txHash||Date.now().toString(36),symbol:l.symbol||i,side:s.toLowerCase(),type:"market",quantity:parseFloat(l.amountIn||a),price:parseFloat(l.effectivePrice||e||0),filledPrice:parseFloat(l.effectivePrice||e||0),filledQty:parseFloat(l.amountOut||a),status:"filled",timestamp:new Date().toISOString(),broker:"Kairos Wallet",real:!0,txHash:l.txHash,chain:l.chain}}catch(d){throw console.error("Wallet DEX placeOrder:",d),d}return{id:Date.now().toString(36),symbol:i,side:s,type:t,quantity:parseFloat(a),price:e?parseFloat(e):null,status:t==="market"?"filled":"new",filledPrice:t==="market"?parseFloat(e||0):null,timestamp:new Date().toISOString(),broker:o.config.name,simulated:!0}}async cancelOrder(n,r,o){const i=this.connections.get(n);if(!i)throw new Error("Broker not connected");if(i.config.id==="binance")try{const s=await this._binanceSignedRequest(i.creds,"DELETE","/api/v3/order",{symbol:o,orderId:r});return{success:!0,orderId:s.orderId,status:s.status}}catch(s){return{success:!1,message:s.message}}if(i.config.id==="coinbase")try{return await this._coinbaseRequest(i.creds,"POST","/api/v3/brokerage/orders/batch_cancel",{order_ids:[r]}),{success:!0,orderId:r}}catch(s){return{success:!1,message:s.message}}if(i.config.id==="bybit")try{return await this._bybitRequest(i.creds,"POST","/v5/order/cancel",{category:"spot",symbol:o,orderId:r}),{success:!0,orderId:r}}catch(s){return{success:!1,message:s.message}}if(i.config.id==="kraken")try{return await this._krakenRequest(i.creds,"/0/private/CancelOrder",{txid:r}),{success:!0,orderId:r}}catch(s){return{success:!1,message:s.message}}if(i.config.id==="kucoin")try{return await this._kucoinRequest(i.creds,"DELETE",`/api/v1/orders/${r}`),{success:!0,orderId:r}}catch(s){return{success:!1,message:s.message}}if(i.config.id==="okx")try{return await this._okxRequest(i.creds,"POST","/api/v5/trade/cancel-order",{instId:o,ordId:r}),{success:!0,orderId:r}}catch(s){return{success:!1,message:s.message}}if(i.config.id==="bingx")try{return await this._bingxRequest(i.creds,"POST","/openApi/spot/v1/trade/cancel",{symbol:o,orderId:r}),{success:!0,orderId:r}}catch(s){return{success:!1,message:s.message}}if(i.config.id==="bitget")try{return await this._bitgetRequest(i.creds,"POST","/api/v2/spot/trade/cancel-order",{symbol:o,orderId:r}),{success:!0,orderId:r}}catch(s){return{success:!1,message:s.message}}if(i.config.id==="mexc")try{return await this._mexcRequest(i.creds,"DELETE","/api/v3/order",{symbol:o,orderId:r}),{success:!0,orderId:r}}catch(s){return{success:!1,message:s.message}}return i.config.id==="wallet"?{success:!1,message:"DEX orders are instant swaps and cannot be cancelled"}:{success:!0,orderId:r,simulated:!0}}async getOpenOrders(n,r){const o=this.connections.get(n);if(!o)throw new Error("Broker not connected");if(o.config.id==="binance")try{const i=r?{symbol:r}:{};return(await this._binanceSignedRequest(o.creds,"GET","/api/v3/openOrders",i)).map(t=>{var a,e,c,g;return{id:(a=t.orderId)==null?void 0:a.toString(),symbol:t.symbol,side:(e=t.side)==null?void 0:e.toLowerCase(),type:(c=t.type)==null?void 0:c.toLowerCase(),quantity:parseFloat(t.origQty),price:parseFloat(t.price),filledQty:parseFloat(t.executedQty),status:(g=t.status)==null?void 0:g.toLowerCase(),time:new Date(t.time).toISOString()}})}catch{return[]}if(o.config.id==="coinbase")try{const i=r?r.replace(/([A-Z]+)(USDT|USDC|USD|BTC|ETH)$/i,"$1-$2").toUpperCase():void 0;let s="/api/v3/brokerage/orders/historical/batch?order_status=OPEN";return i&&(s+=`&product_id=${i}`),((await this._coinbaseRequest(o.creds,"GET",s)).orders||[]).map(a=>{var e,c,g,f,u,p,m;return{id:a.order_id,symbol:a.product_id,side:(e=a.side)==null?void 0:e.toLowerCase(),type:(c=a.order_type)==null?void 0:c.toLowerCase(),quantity:parseFloat(((f=(g=a.order_configuration)==null?void 0:g.limit_limit_gtc)==null?void 0:f.base_size)||0),price:parseFloat(((p=(u=a.order_configuration)==null?void 0:u.limit_limit_gtc)==null?void 0:p.limit_price)||a.average_filled_price||0),filledQty:parseFloat(a.filled_size||0),status:(m=a.status)==null?void 0:m.toLowerCase(),time:a.created_time}})}catch(i){return console.error("[COINBASE] getOpenOrders error:",i.message),[]}return[]}async getTradeHistory(n,r,o=50){const i=this.connections.get(n);if(!i)throw new Error("Broker not connected");if(i.config.id==="binance")try{return(await this._binanceSignedRequest(i.creds,"GET","/api/v3/myTrades",{symbol:r,limit:o})).map(t=>{var a,e;return{id:(a=t.id)==null?void 0:a.toString(),orderId:(e=t.orderId)==null?void 0:e.toString(),symbol:t.symbol,side:t.isBuyer?"buy":"sell",price:parseFloat(t.price),quantity:parseFloat(t.qty),commission:parseFloat(t.commission),commissionAsset:t.commissionAsset,time:new Date(t.time).toISOString(),isMaker:t.isMaker}})}catch{return[]}if(i.config.id==="coinbase")try{const s=r?r.replace(/([A-Z]+)(USDT|USDC|USD|BTC|ETH)$/i,"$1-$2").toUpperCase():void 0;let t=`/api/v3/brokerage/orders/historical/fills?limit=${o}`;return s&&(t+=`&product_id=${s}`),((await this._coinbaseRequest(i.creds,"GET",t)).fills||[]).map(e=>{var c,g,f;return{id:e.trade_id||e.entry_id,orderId:e.order_id,symbol:e.product_id,side:(c=e.side)==null?void 0:c.toLowerCase(),price:parseFloat(e.price||0),quantity:parseFloat(e.size||e.size_in_quote||0),commission:parseFloat(e.commission||0),commissionAsset:((f=(g=e.product_id)==null?void 0:g.split("-"))==null?void 0:f[1])||"USD",time:e.trade_time,isMaker:!1}})}catch(s){return console.error("[COINBASE] getTradeHistory error:",s.message),[]}return[]}async getExchangeInfo(n){var r,o,i,s;try{const a=(r=(await this._binancePublicRequest("/api/v3/exchangeInfo",{symbol:n})).symbols)==null?void 0:r[0];if(!a)return null;const e=(o=a.filters)==null?void 0:o.find(f=>f.filterType==="LOT_SIZE"),c=(i=a.filters)==null?void 0:i.find(f=>f.filterType==="PRICE_FILTER"),g=(s=a.filters)==null?void 0:s.find(f=>f.filterType==="NOTIONAL"||f.filterType==="MIN_NOTIONAL");return{symbol:a.symbol,status:a.status,baseAsset:a.baseAsset,quoteAsset:a.quoteAsset,minQty:e?parseFloat(e.minQty):0,maxQty:e?parseFloat(e.maxQty):1/0,stepSize:e?parseFloat(e.stepSize):0,minPrice:c?parseFloat(c.minPrice):0,tickSize:c?parseFloat(c.tickSize):0,minNotional:g?parseFloat(g.minNotional||g.notional):0}}catch{return null}}isConnected(n){return this.connections.has(n)}getConnection(n){return this.connections.get(n)}disconnect(n){this.connections.delete(n)}}const X=new M;export{X as b};
