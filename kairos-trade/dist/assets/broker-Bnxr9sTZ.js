const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-COfMMj_9.js","assets/index-CllwEhrg.js","assets/ui-CtxJry3a.js","assets/vendor-OqcJHxKq.js","assets/index-BqPK2vH6.css","assets/provider-jsonrpc-BIsgLNZl.js","assets/walletConnectDApp-CxB4PNVb.js"])))=>i.map(i=>d[i]);
import{_ as Q,u as X,B as k,h as J}from"./index-CllwEhrg.js";const Y={56:"https://bsc.api.0x.org",1:"https://api.0x.org",137:"https://polygon.api.0x.org",42161:"https://arbitrum.api.0x.org",8453:"https://base.api.0x.org"},ee="0xCee44904A6aA94dEa28754373887E07D4B6f4968",te=15;let H="aggregator";const q={56:{name:"BSC",rpc:["https://bsc-dataseed1.binance.org","https://bsc-dataseed2.binance.org","https://bsc-dataseed3.binance.org"],router:"0x10ED43C718714eb63d5aA57B78B54704E256024E",factory:"0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73",wrapped:"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",dexName:"PancakeSwap",explorer:"https://bscscan.com",nativeSymbol:"BNB"},1:{name:"Ethereum",rpc:["https://eth.llamarpc.com","https://rpc.ankr.com/eth"],router:"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D",factory:"0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f",wrapped:"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",dexName:"Uniswap",explorer:"https://etherscan.io",nativeSymbol:"ETH"},137:{name:"Polygon",rpc:["https://polygon-rpc.com","https://rpc.ankr.com/polygon"],router:"0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff",factory:"0x5757371414417b8C6CAad45bAeF941aBc7d3Ab32",wrapped:"0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",dexName:"QuickSwap",explorer:"https://polygonscan.com",nativeSymbol:"MATIC"},42161:{name:"Arbitrum",rpc:["https://arb1.arbitrum.io/rpc","https://rpc.ankr.com/arbitrum"],router:"0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506",factory:"0xc35DADB65012eC5796536bD9864eD8773aBc74C4",wrapped:"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",dexName:"SushiSwap",explorer:"https://arbiscan.io",nativeSymbol:"ETH"},43114:{name:"Avalanche",rpc:["https://api.avax.network/ext/bc/C/rpc","https://rpc.ankr.com/avalanche"],router:"0x60aE616a2155Ee3d9A68541Ba4544862310933d4",factory:"0x9Ad6C38BE94206cA50bb0d90783181834C6AbB96",wrapped:"0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",dexName:"Trader Joe",explorer:"https://snowtrace.io",nativeSymbol:"AVAX"},8453:{name:"Base",rpc:["https://mainnet.base.org","https://rpc.ankr.com/base"],router:"0x327Df1E6de05895d2ab08513aaDD9313fE505d86",factory:"0xFDa619b6d20975be80A10332cD39b9a4b0FAa8BB",wrapped:"0x4200000000000000000000000000000000000006",dexName:"BaseSwap",explorer:"https://basescan.org",nativeSymbol:"ETH"}},j={56:{USDT:"0x55d398326f99059fF775485246999027B3197955",USDC:"0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d",BUSD:"0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56",BTC:"0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c",ETH:"0x2170Ed0880ac9A755fd29B2688956BD959F933F8",KAIROS:"0x14D41707269c7D8b8DFa5095b38824a46dA05da3",BNB:"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c"},1:{USDT:"0xdAC17F958D2ee523a2206206994597C13D831ec7",USDC:"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",WETH:"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"},137:{USDT:"0xc2132D05D31c914a87C6611C10748AEb04B58e8F",USDC:"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",KAIROS:"0x9151B8C90B2F8a8DF82426E7E65d00563A75a6C9",WMATIC:"0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270"},42161:{USDT:"0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9",USDC:"0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8",KAIROS:"0x14D41707269c7D8b8DFa5095b38824a46dA05da3",WETH:"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1"},43114:{USDT:"0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7",USDC:"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",WAVAX:"0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7"},8453:{USDC:"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",WETH:"0x4200000000000000000000000000000000000006",KAIROS:"0x14D41707269c7D8b8DFa5095b38824a46dA05da3"}},K=["function balanceOf(address) view returns (uint256)","function decimals() view returns (uint8)","function symbol() view returns (string)","function name() view returns (string)","function allowance(address owner, address spender) view returns (uint256)","function approve(address spender, uint256 amount) returns (bool)"],z=["function getAmountsOut(uint amountIn, address[] path) view returns (uint[] amounts)","function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] path, address to, uint deadline) returns (uint[] amounts)","function swapExactETHForTokens(uint amountOutMin, address[] path, address to, uint deadline) payable returns (uint[] amounts)","function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] path, address to, uint deadline) returns (uint[] amounts)","function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] path, address to, uint deadline)","function WETH() view returns (address)"];let N=null;async function L(){if(N)return N;try{return N=await Q(()=>import("./index-COfMMj_9.js"),__vite__mapDeps([0,1,2,3,4,5])),N}catch{if(window.ethers)return N=window.ethers,N;throw new Error("ethers.js not available. Install with: npm install ethers")}}class re{constructor(){this.providers={},this.wallets={},this.executionMode=H}setExecutionMode(c){if(!["aggregator","direct"].includes(c))throw new Error('Invalid mode. Use "aggregator" or "direct"');this.executionMode=c,H=c,console.log(`[BROKER] Execution mode â†’ ${c==="aggregator"?"ðŸ”„ Aggregator (100+ DEXes)":"ðŸ“ Direct (single DEX)"}`)}getExecutionMode(){return this.executionMode}async _getAggregatorQuote(c,s,i,o){const a=Y[c];if(!a)return null;q[c];const r=new URLSearchParams({sellToken:s,buyToken:i,sellAmount:o.toString(),slippagePercentage:"0.005",feeRecipient:ee,buyTokenPercentageFee:(te/1e4).toString(),enableSlippageProtection:"true"});try{const t=await fetch(`${a}/swap/v1/quote?${r}`,{headers:{"0x-api-key":""}});if(!t.ok){const l=await t.json().catch(()=>({}));return console.warn(`[AGGREGATOR] Quote failed (${t.status}):`,(l==null?void 0:l.reason)||"Unknown"),null}const e=await t.json(),n=(e.sources||[]).filter(l=>parseFloat(l.proportion)>0).map(l=>({name:l.name,pct:Math.round(parseFloat(l.proportion)*100)})).sort((l,u)=>u.pct-l.pct);return{buyAmount:e.buyAmount,to:e.to,data:e.data,value:e.value||"0",gasEstimate:e.estimatedGas,allowanceTarget:e.allowanceTarget,sources:n,sourceSummary:n.map(l=>`${l.name} ${l.pct}%`).join(" + ")||"Direct",price:e.price,guaranteedPrice:e.guaranteedPrice}}catch(t){return console.warn("[AGGREGATOR] Error:",t.message),null}}async _executeAggregatorSwap(c,s,i,o,a){const r=await L(),t=q[s];if(!(i.toLowerCase()===t.wrapped.toLowerCase())&&a.allowanceTarget){const u=new r.Contract(i,K,c);await u.allowance(c.address,a.allowanceTarget)<BigInt(o)&&(console.log(`[AGGREGATOR] Approving token for ${a.sourceSummary}...`),await(await u.approve(a.allowanceTarget,r.MaxUint256)).wait(),console.log("[AGGREGATOR] Approval confirmed"))}const n=await c.sendTransaction({to:a.to,data:a.data,value:a.value,gasLimit:Math.ceil(Number(a.gasEstimate||3e5)*1.3)});console.log(`[AGGREGATOR] Swap tx: ${n.hash} via ${a.sourceSummary}`);const l=await n.wait();return{tx:n,receipt:l,sources:a.sources,sourceSummary:a.sourceSummary}}async _getProvider(c){if(this.providers[c])return this.providers[c];const s=await L(),i=q[c];if(!i)throw new Error(`Unsupported chain: ${c}`);for(const o of i.rpc)try{const a=new s.JsonRpcProvider(o,c);return await a.getBlockNumber(),this.providers[c]=a,a}catch{continue}throw new Error(`Could not connect to ${i.name} RPC`)}async _getWallet(c,s){const i=`${s}-${c.slice(-6)}`;if(this.wallets[i])return this.wallets[i];const o=await L(),a=await this._getProvider(s),r=new o.Wallet(c,a);return this.wallets[i]=r,r}_resolveToken(c,s){if(c!=null&&c.startsWith("0x")&&c.length===42)return c;const i=j[s]||{},o=(c||"").toUpperCase(),a=o.replace("KAIROS","").replace("USDT","").replace("USDC","");return i[o]||i[a]||null}async connect(c,s,i=56){try{const o=await L(),a=q[i];if(!a)return{success:!1,message:`Red no soportada: ${i}`};if(!o.isAddress(c))return{success:!1,message:"DirecciÃ³n de wallet invÃ¡lida"};try{if(new o.Wallet(s).address.toLowerCase()!==c.toLowerCase())return{success:!1,message:"La clave privada no corresponde a la direcciÃ³n"}}catch{return{success:!1,message:"Clave privada invÃ¡lida"}}const t=await(await this._getProvider(i)).getBalance(c),e=o.formatEther(t);return{success:!0,message:`Conectado a ${a.name} via ${this.executionMode==="aggregator"?"Kairos Exchange (100+ DEXes)":a.dexName} (${parseFloat(e).toFixed(4)} ${a.nativeSymbol})`,chain:a.name,dex:this.executionMode==="aggregator"?"Kairos Exchange":a.dexName,executionMode:this.executionMode,nativeBalance:e}}catch(o){return{success:!1,message:`Error: ${o.message}`}}}async getBalances(c,s=56){const i=await L(),o=await this._getProvider(s),a=q[s],r=j[s]||{},t=[];try{const e=await o.getBalance(c),n=i.formatEther(e);parseFloat(n)>0&&t.push({asset:a.nativeSymbol,free:n,locked:"0",total:n,native:!0})}catch(e){console.warn("Native balance error:",e.message)}for(const[e,n]of Object.entries(r))if(n.toLowerCase()!==a.wrapped.toLowerCase())try{const l=new i.Contract(n,K,o),[u,m]=await Promise.all([l.balanceOf(c),l.decimals()]),p=i.formatUnits(u,m);parseFloat(p)>1e-6&&t.push({asset:e,free:p,locked:"0",total:p})}catch(l){console.warn(`Token ${e} balance error:`,l.message)}return t}async getQuote(c,s,i,o){const a=await L(),r=await this._getProvider(c),t=q[c],e=this._resolveToken(s,c),n=this._resolveToken(i,c);if(!e||!n)throw new Error(`Token not found: ${s} or ${i}`);let l=18;e.toLowerCase()!==t.wrapped.toLowerCase()&&(l=await new a.Contract(e,K,r).decimals());let u=18;n.toLowerCase()!==t.wrapped.toLowerCase()&&(u=await new a.Contract(n,K,r).decimals());const m=a.parseUnits(o.toString(),l);if(this.executionMode==="aggregator")try{const g=await this._getAggregatorQuote(c,e,n,m);if(g){const h=a.formatUnits(g.buyAmount,u),C=parseFloat(h)/parseFloat(o);console.log(`[QUOTE] Aggregator â†’ ${h} via ${g.sourceSummary}`);let b=null;try{b=await this._getDirectQuote(c,e,n,m,u,t)}catch{}const S=b?((parseFloat(h)-b.amountOutNum)/b.amountOutNum*100).toFixed(2):null;return{amountIn:o.toString(),amountOut:h,effectivePrice:C,dex:"Kairos Exchange",mode:"aggregator",sources:g.sources,sourceSummary:g.sourceSummary,priceImpact:"optimized",savingsVsDirect:S?`${S>0?"+":""}${S}%`:null,directDex:(b==null?void 0:b.dex)||null,_aggQuoteData:g}}}catch(g){console.warn("[QUOTE] Aggregator failed, falling back to direct DEX:",g.message)}const p=await this._getDirectQuote(c,e,n,m,u,t);return{amountIn:o.toString(),amountOut:p.formattedOut,effectivePrice:p.effectivePrice,path:p.path,dex:t.dexName,mode:"direct",sources:[{name:t.dexName,pct:100}],sourceSummary:t.dexName,priceImpact:p.path.length>2?"multi-hop":"direct",savingsVsDirect:null}}async _getDirectQuote(c,s,i,o,a,r){const t=await L(),e=await this._getProvider(c),n=new t.Contract(r.router,z,e),l=[[s,i],[s,r.wrapped,i]];for(const u of l)try{const m=await n.getAmountsOut(o,u),p=m[m.length-1],g=t.formatUnits(p,a),h=parseFloat(g),C=h/parseFloat(t.formatUnits(o,18));return{formattedOut:g,effectivePrice:C,amountOutNum:h,path:u,dex:r.dexName}}catch{continue}throw new Error(`No liquidity found on ${r.dexName}`)}async placeOrder(c,s,i){var x,_;const o=await L(),a=q[s];if(!a)throw new Error(`Unsupported chain: ${s}`);const{symbol:r,side:t,quantity:e,price:n}=i;let l,u;const m=r.match(/^([A-Z]+)(USDT|USDC|BUSD|KAIROS|BNB|ETH|WETH|WBNB|MATIC|AVAX)$/i);if(m)l=m[1].toUpperCase(),u=m[2].toUpperCase(),u==="KAIROS"&&(u="USDT");else throw new Error(`Invalid pair format: ${r}. Expected e.g. BTCUSDT`);const p=this._resolveToken(l,s),g=this._resolveToken(u,s);if(!p)throw new Error(`Token ${l} not found on chain ${s}`);if(!g)throw new Error(`Token ${u} not found on chain ${s}`);const h=await this._getWallet(c,s);let C,b,S;t.toLowerCase()==="buy"?(C=g,b=p,S=(parseFloat(e)*parseFloat(n||1)).toString()):(C=p,b=g,S=e.toString());const v=C.toLowerCase()===a.wrapped.toLowerCase(),R=b.toLowerCase()===a.wrapped.toLowerCase();let I=18;v||(I=await new o.Contract(C,K,h.provider).decimals());let A=18;R||(A=await new o.Contract(b,K,h.provider).decimals());const F=o.parseUnits(S,I);if(this.executionMode==="aggregator")try{const E=await this._getAggregatorQuote(s,C,b,F);if(E){console.log(`[ORDER] Executing via Aggregator â†’ ${E.sourceSummary}`);const T=await this._executeAggregatorSwap(h,s,C,F,E),P=o.formatUnits(E.buyAmount,A);return{success:!0,txHash:T.tx.hash,symbol:r,side:t.toLowerCase(),amountIn:S,amountOut:P,effectivePrice:t.toLowerCase()==="buy"?parseFloat(S)/parseFloat(P):parseFloat(P)/parseFloat(S),chain:a.name,dex:"Kairos Exchange",mode:"aggregator",sources:T.sources,sourceSummary:T.sourceSummary,explorer:`${a.explorer}/tx/${T.tx.hash}`,gasUsed:(x=T.receipt.gasUsed)==null?void 0:x.toString(),blockNumber:T.receipt.blockNumber}}}catch(E){console.warn("[ORDER] Aggregator execution failed, falling back to direct DEX:",E.message)}console.log(`[ORDER] Executing via Direct â†’ ${a.dexName}`);const U=new o.Contract(a.router,z,h);let O;try{await U.getAmountsOut(F,[C,b]),O=[C,b]}catch{O=[C,a.wrapped,b];try{await U.getAmountsOut(F,O)}catch{throw new Error(`No liquidity for ${l}/${u} on ${a.dexName}`)}}const M=await U.getAmountsOut(F,O),G=M[M.length-1],f=G*BigInt(Math.floor((1-.5/100)*1e4))/10000n,d=Math.floor(Date.now()/1e3)+300;if(!v){const E=new o.Contract(C,K,h);await E.allowance(h.address,a.router)<F&&(console.log(`[WALLET] Approving ${l} for ${a.dexName}...`),await(await E.approve(a.router,o.MaxUint256)).wait(),console.log("[WALLET] Approval confirmed"))}let w;if(v)w=await U.swapExactETHForTokens(f,O,h.address,d,{value:F});else if(R)w=await U.swapExactTokensForETH(F,f,O,h.address,d);else try{w=await U.swapExactTokensForTokensSupportingFeeOnTransferTokens(F,f,O,h.address,d)}catch{w=await U.swapExactTokensForTokens(F,f,O,h.address,d)}console.log(`[WALLET] Swap tx: ${w.hash}`);const B=await w.wait(),D=o.formatUnits(G,A),$=parseFloat(D)/parseFloat(S);return{success:!0,txHash:w.hash,symbol:r,side:t.toLowerCase(),amountIn:S,amountOut:D,effectivePrice:t.toLowerCase()==="buy"?parseFloat(S)/parseFloat(D):$,chain:a.name,dex:a.dexName,mode:"direct",sources:[{name:a.dexName,pct:100}],sourceSummary:a.dexName,explorer:`${a.explorer}/tx/${w.hash}`,gasUsed:(_=B.gasUsed)==null?void 0:_.toString(),blockNumber:B.blockNumber}}async cancelOrder(){return{success:!1,message:"DEX swaps are instant and cannot be cancelled"}}async sendViaWalletConnect(c,s){try{const{sendTransaction:i}=await Q(async()=>{const{sendTransaction:r}=await import("./walletConnectDApp-CxB4PNVb.js");return{sendTransaction:r}},__vite__mapDeps([6,2])),o=await i(c,s),a=q[c];return{success:!0,txHash:o,explorer:a?`${a.explorer}/tx/${o}`:null,chain:(a==null?void 0:a.name)||`Chain ${c}`,method:"WalletConnect"}}catch(i){return{success:!1,message:`WalletConnect: ${i.message}`}}}async isWCAvailable(){try{const{isConnected:c}=await Q(async()=>{const{isConnected:s}=await import("./walletConnectDApp-CxB4PNVb.js");return{isConnected:s}},__vite__mapDeps([6,2]));return c()}catch{return!1}}async getWCAccount(){try{const{getConnectedAccount:c}=await Q(async()=>{const{getConnectedAccount:s}=await import("./walletConnectDApp-CxB4PNVb.js");return{getConnectedAccount:s}},__vite__mapDeps([6,2]));return c()}catch{return null}}}const ae=new re,W="https://kairos-api-u6k5.onrender.com";class se{constructor(){this.connections=new Map}async _decrypt(c){var o;const s=`kairos:broker:${((o=X.getState().user)==null?void 0:o.email)||"anon"}`,i=async a=>{if(a){if(a.startsWith("v1:")){const{privateKey:r}=await J(a,s);return r}try{return atob(a)}catch{return a}}};return{...c,apiKey:await i(c.apiKey),apiSecret:await i(c.apiSecret),passphrase:await i(c.passphrase)}}async _coinbaseJWT(c,s,i){const o=c.apiKey,a=c.apiSecret,r={alg:"ES256",kid:o,nonce:crypto.randomUUID(),typ:"JWT"},t=Math.floor(Date.now()/1e3),e=`${s} api.coinbase.com${i}`,n={sub:o,iss:"coinbase-cloud",aud:["cdp_service"],nbf:t,exp:t+120,uri:e},l=S=>btoa(S).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),u=S=>l(JSON.stringify(S)),m=S=>l(String.fromCharCode(...new Uint8Array(S))),p=u(r),g=u(n),h=`${p}.${g}`,C=await this._importECKey(a),b=await crypto.subtle.sign({name:"ECDSA",hash:"SHA-256"},C,new TextEncoder().encode(h));return`${h}.${m(b)}`}async _importECKey(c){const s=c.replace(/-----BEGIN (?:EC )?PRIVATE KEY-----/g,"").replace(/-----END (?:EC )?PRIVATE KEY-----/g,"").replace(/\\n/g,"").replace(/\n/g,"").replace(/\r/g,"").replace(/\s/g,""),i=Uint8Array.from(atob(s),e=>e.charCodeAt(0));if(c.includes("BEGIN PRIVATE KEY")&&!c.includes("EC PRIVATE KEY"))return crypto.subtle.importKey("pkcs8",i.buffer,{name:"ECDSA",namedCurve:"P-256"},!1,["sign"]);const o=this._extractEC_d(i),a=this._extractEC_pub(i);if(!o||o.length!==32)throw new Error(`Clave EC invÃ¡lida: se esperaban 32 bytes para d, se encontraron ${(o==null?void 0:o.length)||0}`);const r=e=>btoa(String.fromCharCode(...e)).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),t={kty:"EC",crv:"P-256",d:r(o)};if(a&&a.length===65&&a[0]===4)t.x=r(a.slice(1,33)),t.y=r(a.slice(33,65));else return this._importECKeyPkcs8Wrap(i);return crypto.subtle.importKey("jwk",t,{name:"ECDSA",namedCurve:"P-256"},!1,["sign"])}_extractEC_d(c){for(let s=0;s<c.length-34;s++)if(c[s]===2&&c[s+1]===1&&c[s+2]===1&&c[s+3]===4&&c[s+4]===32)return c.slice(s+5,s+5+32);return null}_extractEC_pub(c){for(let s=0;s<c.length-67;s++)if(c[s]===161&&c[s+2]===3&&c[s+3]===66&&c[s+4]===0)return c.slice(s+5,s+5+65);return null}async _importECKeyPkcs8Wrap(c){const s=c.length,i=new Uint8Array([48,19,6,7,42,134,72,206,61,2,1,6,8,42,134,72,206,61,3,1,7]),o=new Uint8Array([2,1,0]),a=this._asn1Len(4,s),r=o.length+i.length+a.length+s,t=this._asn1Len(48,r),e=new Uint8Array(t.length+r);let n=0;return e.set(t,n),n+=t.length,e.set(o,n),n+=o.length,e.set(i,n),n+=i.length,e.set(a,n),n+=a.length,e.set(c,n),crypto.subtle.importKey("pkcs8",e.buffer,{name:"ECDSA",namedCurve:"P-256"},!1,["sign"])}_asn1Len(c,s){return s<128?new Uint8Array([c,s]):s<256?new Uint8Array([c,129,s]):new Uint8Array([c,130,s>>8&255,s&255])}async _coinbaseRequest(c,s,i,o=null){const a=await this._coinbaseJWT(c,s,i),r="/api/coinbase-proxy";try{const t=await fetch(r,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jwt:a,method:s,path:i,body:o})});let e;const n=await t.text();try{e=JSON.parse(n)}catch{e={error:n}}if(!t.ok)throw new Error(e.error||e.message||`Coinbase HTTP ${t.status}`);return e}catch(t){throw t.message==="Failed to fetch"||t.name==="TypeError"?new Error("Error de red al conectar con el proxy. Reintenta en unos segundos."):t}}async _hmacSign(c,s){const i=new TextEncoder,o=await crypto.subtle.importKey("raw",i.encode(c),{name:"HMAC",hash:"SHA-256"},!1,["sign"]),a=await crypto.subtle.sign("HMAC",o,i.encode(s));return Array.from(new Uint8Array(a)).map(r=>r.toString(16).padStart(2,"0")).join("")}async _hmacSignB64(c,s,i=!1){const o=new TextEncoder;let a;if(i){const e=atob(c);a=new Uint8Array(e.length);for(let n=0;n<e.length;n++)a[n]=e.charCodeAt(n)}else a=o.encode(c);const r=await crypto.subtle.importKey("raw",a,{name:"HMAC",hash:"SHA-256"},!1,["sign"]),t=await crypto.subtle.sign("HMAC",r,o.encode(s));return btoa(String.fromCharCode(...new Uint8Array(t)))}async _hmacSignSHA512B64(c,s){const i=atob(c),o=new Uint8Array(i.length);for(let e=0;e<i.length;e++)o[e]=i.charCodeAt(e);const a=await crypto.subtle.importKey("raw",o,{name:"HMAC",hash:"SHA-512"},!1,["sign"]),r=typeof s=="string"?new TextEncoder().encode(s):s,t=await crypto.subtle.sign("HMAC",a,r);return btoa(String.fromCharCode(...new Uint8Array(t)))}async _sha256(c){const s=new TextEncoder().encode(c),i=await crypto.subtle.digest("SHA-256",s);return new Uint8Array(i)}async _proxyRequest(c,s,i={},o=null){const a=await fetch("/api/broker-proxy",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({url:c,method:s,headers:i,body:o})}),r=await a.text();let t;try{t=JSON.parse(r)}catch{t={error:r}}if(!a.ok)throw new Error(t.error||t.message||t.msg||`HTTP ${a.status}`);return t}async _bybitRequest(c,s,i,o={}){const a=Date.now().toString(),r="5000";let t="",e="";s==="GET"?t=Object.entries(o).filter(([,g])=>g!=null).map(([g,h])=>`${g}=${h}`).join("&"):e=JSON.stringify(o);const n=`${a}${c.apiKey}${r}${s==="GET"?t:e}`,l=await this._hmacSign(c.apiSecret,n),u=`${k.bybit.baseUrl}${i}${t?"?"+t:""}`,m={"X-BAPI-API-KEY":c.apiKey,"X-BAPI-SIGN":l,"X-BAPI-SIGN-TYPE":"2","X-BAPI-TIMESTAMP":a,"X-BAPI-RECV-WINDOW":r,"Content-Type":"application/json"},p=await this._proxyRequest(u,s,m,s!=="GET"?o:null);if(p.retCode!==0&&p.retCode!==void 0)throw new Error(`Bybit: ${p.retMsg||"Unknown error"} (${p.retCode})`);return p.result||p}async _krakenRequest(c,s,i={}){const o=Date.now().toString(),a=new URLSearchParams({...i,nonce:o}).toString(),r=await this._sha256(o+a),t=new TextEncoder().encode(s),e=new Uint8Array(t.length+r.length);e.set(t,0),e.set(r,t.length);const n=await this._hmacSignSHA512B64(c.apiSecret,e),l=`${k.kraken.baseUrl}${s}`,u={"API-Key":c.apiKey,"API-Sign":n,"Content-Type":"application/x-www-form-urlencoded"},m=await this._proxyRequest(l,"POST",u,a);if(m.error&&m.error.length>0)throw new Error(`Kraken: ${m.error.join(", ")}`);return m.result||m}async _kucoinRequest(c,s,i,o={}){const a=Date.now().toString();let r="",t="";s==="GET"||s==="DELETE"?(t=Object.entries(o).filter(([,g])=>g!=null).map(([g,h])=>`${g}=${h}`).join("&"),t&&(i=`${i}?${t}`)):r=JSON.stringify(o);const e=`${a}${s}${i}${r}`,n=await this._hmacSignB64(c.apiSecret,e),l=await this._hmacSignB64(c.apiSecret,c.passphrase||""),u=`${k.kucoin.baseUrl}${i}`,m={"KC-API-KEY":c.apiKey,"KC-API-SIGN":n,"KC-API-TIMESTAMP":a,"KC-API-PASSPHRASE":l,"KC-API-KEY-VERSION":"2","Content-Type":"application/json"},p=await this._proxyRequest(u,s,m,s!=="GET"&&s!=="DELETE"?o:null);if(p.code&&p.code!=="200000")throw new Error(`KuCoin: ${p.msg||"Unknown error"} (${p.code})`);return p.data||p}async _okxRequest(c,s,i,o={}){const a=new Date().toISOString();let r="",t="";s==="GET"?(t=Object.entries(o).filter(([,p])=>p!=null).map(([p,g])=>`${p}=${g}`).join("&"),t&&(i=`${i}?${t}`)):r=JSON.stringify(o);const e=`${a}${s}${i}${r}`,n=await this._hmacSignB64(c.apiSecret,e),l=`${k.okx.baseUrl}${i}`,u={"OK-ACCESS-KEY":c.apiKey,"OK-ACCESS-SIGN":n,"OK-ACCESS-TIMESTAMP":a,"OK-ACCESS-PASSPHRASE":c.passphrase||"","Content-Type":"application/json"},m=await this._proxyRequest(l,s,u,s!=="GET"?o:null);if(m.code&&m.code!=="0")throw new Error(`OKX: ${m.msg||"Unknown error"} (${m.code})`);return m.data||m}async _bingxRequest(c,s,i,o={}){const a=Date.now().toString(),r={...o,timestamp:a},t=Object.entries(r).sort(([p],[g])=>p.localeCompare(g)).filter(([,p])=>p!=null).map(([p,g])=>`${p}=${encodeURIComponent(g)}`).join("&"),e=await this._hmacSign(c.apiSecret,t),n=`${t}&signature=${e}`,l=`${k.bingx.baseUrl}${i}?${n}`,u={"X-BX-APIKEY":c.apiKey,"Content-Type":"application/json"},m=await this._proxyRequest(l,s,u,s!=="GET"?o:null);if(m.code&&m.code!==0)throw new Error(`BingX: ${m.msg||"Unknown error"} (${m.code})`);return m.data||m}async _bitgetRequest(c,s,i,o={}){const a=Date.now().toString();let r="",t="";s==="GET"?(t=Object.entries(o).filter(([,p])=>p!=null).map(([p,g])=>`${p}=${g}`).join("&"),t&&(i=`${i}?${t}`)):r=JSON.stringify(o);const e=`${a}${s}${i}${r}`,n=await this._hmacSignB64(c.apiSecret,e),l=`${k.bitget.baseUrl}${i}`,u={"ACCESS-KEY":c.apiKey,"ACCESS-SIGN":n,"ACCESS-TIMESTAMP":a,"ACCESS-PASSPHRASE":c.passphrase||"","Content-Type":"application/json",locale:"en-US"},m=await this._proxyRequest(l,s,u,s!=="GET"?o:null);if(m.code&&m.code!=="00000")throw new Error(`Bitget: ${m.msg||"Unknown error"} (${m.code})`);return m.data||m}async _mexcRequest(c,s,i,o={}){const a=Date.now(),r={...o,timestamp:a,recvWindow:5e3},t=Object.entries(r).filter(([,g])=>g!=null).map(([g,h])=>`${g}=${encodeURIComponent(h)}`).join("&"),e=await this._hmacSign(c.apiSecret,t),n=`${t}&signature=${e}`,l=s==="GET"?`${k.mexc.baseUrl}${i}?${n}`:`${k.mexc.baseUrl}${i}`,u={"X-MEXC-APIKEY":c.apiKey,"Content-Type":"application/json"},m=s!=="GET"?n:null,p=await this._proxyRequest(l,s,u,m);if(p.code&&p.code!==0&&p.code!==200)throw new Error(`MEXC: ${p.msg||"Unknown error"} (${p.code})`);return p}async _binanceSignedRequest(c,s,i,o={}){const a=Date.now(),r={...o,timestamp:a,recvWindow:5e3},t=Object.entries(r).filter(([,g])=>g!=null).map(([g,h])=>`${g}=${encodeURIComponent(h)}`).join("&"),e=await this._hmacSign(c.apiSecret,t),n=`${t}&signature=${e}`,l=s==="GET"?`${k.binance.baseUrl}${i}?${n}`:`${k.binance.baseUrl}${i}`,u={method:s,headers:{"X-MBX-APIKEY":c.apiKey,"Content-Type":"application/x-www-form-urlencoded"}};(s==="POST"||s==="DELETE")&&(u.body=n);const m=await fetch(l,u),p=await m.json();if(!m.ok)throw new Error(`Binance ${i}: ${p.msg||m.statusText} (${p.code||m.status})`);return p}async _binancePublicRequest(c,s={}){const i=Object.entries(s).filter(([,r])=>r!==void 0).map(([r,t])=>`${r}=${encodeURIComponent(t)}`).join("&"),o=`${k.binance.baseUrl}${c}${i?"?"+i:""}`,a=await fetch(o);if(!a.ok)throw new Error(`Binance API error: ${a.status}`);return a.json()}async connect(c){var o,a,r,t;const s=await this._decrypt(c),i=k[c.brokerId];if(!i)throw new Error(`Unsupported broker: ${c.brokerId}`);try{switch(c.brokerId){case"binance":{await this._binancePublicRequest("/api/v3/ping");const e=await this._binanceSignedRequest(s,"GET","/api/v3/account");return this.connections.set(c.id,{creds:s,config:i,connected:!0,permissions:e.permissions||[],accountType:e.accountType}),{success:!0,message:`Connected to Binance (${e.accountType})`,permissions:e.permissions}}case"coinbase":{const e=await this._coinbaseRequest(s,"GET","/api/v3/brokerage/accounts?limit=250");return this.connections.set(c.id,{creds:s,config:i,connected:!0,permissions:["read","trade"],accounts:e.accounts||[]}),{success:!0,message:`Connected to Coinbase (${(e.accounts||[]).length} accounts)`,permissions:["read","trade"]}}case"bybit":{const e=await this._bybitRequest(s,"GET","/v5/account/wallet-balance",{accountType:"UNIFIED"}),n=((r=(a=(o=e==null?void 0:e.list)==null?void 0:o[0])==null?void 0:a.coin)==null?void 0:r.length)||0;return this.connections.set(c.id,{creds:s,config:i,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to Bybit (${n} assets)`,permissions:["read","trade"]}}case"kraken":{const e=await this._krakenRequest(s,"/0/private/Balance"),n=Object.keys(e||{}).length;return this.connections.set(c.id,{creds:s,config:i,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to Kraken (${n} assets)`,permissions:["read","trade"]}}case"kucoin":{const e=await this._kucoinRequest(s,"GET","/api/v1/accounts"),n=Array.isArray(e)?e.length:0;return this.connections.set(c.id,{creds:s,config:i,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to KuCoin (${n} accounts)`,permissions:["read","trade"]}}case"okx":{const e=await this._okxRequest(s,"GET","/api/v5/account/balance"),n=Array.isArray(e)&&((t=e[0])!=null&&t.details)?e[0].details.length:0;return this.connections.set(c.id,{creds:s,config:i,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to OKX (${n} assets)`,permissions:["read","trade"]}}case"bingx":{const e=await this._bingxRequest(s,"GET","/openApi/spot/v1/account/balance"),n=Array.isArray(e==null?void 0:e.balances)?e.balances.filter(l=>parseFloat(l.free)>0).length:0;return this.connections.set(c.id,{creds:s,config:i,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to BingX (${n} assets)`,permissions:["read","trade"]}}case"bitget":{const e=await this._bitgetRequest(s,"GET","/api/v2/spot/account/assets"),n=Array.isArray(e)?e.filter(l=>parseFloat(l.available)>0).length:0;return this.connections.set(c.id,{creds:s,config:i,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to Bitget (${n} assets)`,permissions:["read","trade"]}}case"mexc":{const e=await this._mexcRequest(s,"GET","/api/v3/account"),n=Array.isArray(e==null?void 0:e.balances)?e.balances.filter(l=>parseFloat(l.free)>0).length:0;return this.connections.set(c.id,{creds:s,config:i,connected:!0,permissions:["read","trade"]}),{success:!0,message:`Connected to MEXC (${n} assets)`,permissions:["read","trade"]}}default:return await fetch(i.baseUrl),this.connections.set(c.id,{creds:s,config:i,connected:!0,permissions:[]}),{success:!0,message:`Connected to ${i.name}`}}}catch(e){return{success:!1,message:e.message}}}async getBalances(c){var i,o,a;const s=this.connections.get(c);if(!s)throw new Error("Broker not connected");if(s.config.id==="binance")try{return(await this._binanceSignedRequest(s.creds,"GET","/api/v3/account")).balances.filter(t=>parseFloat(t.free)>0||parseFloat(t.locked)>0).map(t=>({asset:t.asset,free:t.free,locked:t.locked,total:(parseFloat(t.free)+parseFloat(t.locked)).toString()}))}catch(r){throw console.error("Binance getBalances error:",r),r}if(s.config.id==="coinbase")try{return((await this._coinbaseRequest(s.creds,"GET","/api/v3/brokerage/accounts?limit=250")).accounts||[]).map(n=>{var l,u,m,p;return{asset:n.currency,free:((l=n.available_balance)==null?void 0:l.value)||"0",locked:((u=n.hold)==null?void 0:u.value)||"0",total:(parseFloat(((m=n.available_balance)==null?void 0:m.value)||0)+parseFloat(((p=n.hold)==null?void 0:p.value)||0)).toString(),name:n.name}}).filter(n=>parseFloat(n.free)>0||parseFloat(n.locked)>0)}catch(r){throw console.error("Coinbase getBalances:",r),r}if(s.config.id==="bybit")try{const r=await this._bybitRequest(s.creds,"GET","/v5/account/wallet-balance",{accountType:"UNIFIED"});return(((o=(i=r==null?void 0:r.list)==null?void 0:i[0])==null?void 0:o.coin)||[]).filter(e=>parseFloat(e.walletBalance)>0).map(e=>({asset:e.coin,free:e.availableToWithdraw||e.walletBalance||"0",locked:(parseFloat(e.walletBalance||0)-parseFloat(e.availableToWithdraw||0)).toString(),total:e.walletBalance||"0"}))}catch(r){throw console.error("Bybit getBalances:",r),r}if(s.config.id==="kraken")try{const r=await this._krakenRequest(s.creds,"/0/private/Balance"),t={XXBT:"BTC",XETH:"ETH",ZUSD:"USD",XXRP:"XRP",XLTC:"LTC",XXLM:"XLM",XDOGE:"DOGE"};return Object.entries(r||{}).filter(([,e])=>parseFloat(e)>0).map(([e,n])=>({asset:t[e]||e.replace(/^[XZ]/,""),free:n,locked:"0",total:n}))}catch(r){throw console.error("Kraken getBalances:",r),r}if(s.config.id==="kucoin")try{const r=await this._kucoinRequest(s.creds,"GET","/api/v1/accounts",{type:"trade"});return(Array.isArray(r)?r:[]).filter(t=>parseFloat(t.balance)>0).map(t=>({asset:t.currency,free:t.available||"0",locked:t.holds||"0",total:t.balance||"0"}))}catch(r){throw console.error("KuCoin getBalances:",r),r}if(s.config.id==="okx")try{const r=await this._okxRequest(s.creds,"GET","/api/v5/account/balance");return(Array.isArray(r)&&((a=r[0])!=null&&a.details)?r[0].details:[]).filter(e=>parseFloat(e.cashBal)>0).map(e=>({asset:e.ccy,free:e.availBal||e.cashBal||"0",locked:e.frozenBal||"0",total:e.cashBal||"0"}))}catch(r){throw console.error("OKX getBalances:",r),r}if(s.config.id==="bingx")try{const r=await this._bingxRequest(s.creds,"GET","/openApi/spot/v1/account/balance");return((r==null?void 0:r.balances)||(Array.isArray(r)?r:[])).filter(e=>parseFloat(e.free||e.available||0)>0).map(e=>({asset:e.asset||e.currency,free:e.free||e.available||"0",locked:e.locked||e.freeze||"0",total:(parseFloat(e.free||e.available||0)+parseFloat(e.locked||e.freeze||0)).toString()}))}catch(r){throw console.error("BingX getBalances:",r),r}if(s.config.id==="bitget")try{const r=await this._bitgetRequest(s.creds,"GET","/api/v2/spot/account/assets");return(Array.isArray(r)?r:[]).filter(e=>parseFloat(e.available||0)>0).map(e=>({asset:e.coin||e.coinName,free:e.available||"0",locked:e.frozen||e.lock||"0",total:(parseFloat(e.available||0)+parseFloat(e.frozen||e.lock||0)).toString()}))}catch(r){throw console.error("Bitget getBalances:",r),r}if(s.config.id==="mexc")try{const r=await this._mexcRequest(s.creds,"GET","/api/v3/account");return(Array.isArray(r==null?void 0:r.balances)?r.balances:[]).filter(e=>parseFloat(e.free||0)>0).map(e=>({asset:e.asset,free:e.free||"0",locked:e.locked||"0",total:(parseFloat(e.free||0)+parseFloat(e.locked||0)).toString()}))}catch(r){throw console.error("MEXC getBalances:",r),r}return[]}async placeOrder(c,s){var u,m,p,g,h,C,b,S,v,R,I,A,F,U,O,M,G;const i=this.connections.get(c);if(!i)throw new Error("Broker not connected");const{symbol:o,side:a,type:r,quantity:t,price:e,stopLoss:n,takeProfit:l}=s;if(!o||!a||!r||!t)throw new Error("Missing required order fields");if(i.config.id==="binance")try{const y={market:"MARKET",limit:"LIMIT",stop_loss:"STOP_LOSS_LIMIT"}[r]||"MARKET",f={symbol:o,side:a.toUpperCase(),type:y,quantity:t.toString()};(y==="LIMIT"||y==="STOP_LOSS_LIMIT")&&(f.timeInForce="GTC",f.price=parseFloat(e).toFixed(2)),y==="STOP_LOSS_LIMIT"&&(f.stopPrice=parseFloat(n||e).toFixed(2));const d=await this._binanceSignedRequest(i.creds,"POST","/api/v3/order",f);return{id:(u=d.orderId)==null?void 0:u.toString(),clientOrderId:d.clientOrderId,symbol:d.symbol,side:(m=d.side)==null?void 0:m.toLowerCase(),type:(p=d.type)==null?void 0:p.toLowerCase(),quantity:parseFloat(d.origQty||t),price:parseFloat(d.price||e||0),filledPrice:parseFloat(((h=(g=d.fills)==null?void 0:g[0])==null?void 0:h.price)||d.price||0),filledQty:parseFloat(d.executedQty||0),status:(C=d.status)==null?void 0:C.toLowerCase(),timestamp:new Date(d.transactTime||Date.now()).toISOString(),broker:"Binance",real:!0,raw:d}}catch(y){throw console.error("Binance placeOrder error:",y),y}if(i.config.id==="coinbase")try{const y=o.replace(/([A-Z]+)(USDT|USDC|USD|BTC|ETH)$/i,"$1-$2").toUpperCase(),f={};r==="market"?a.toLowerCase()==="buy"?f.market_market_ioc={quote_size:(parseFloat(t)*parseFloat(e||0)).toFixed(2)}:f.market_market_ioc={base_size:parseFloat(t).toString()}:r==="limit"&&(f.limit_limit_gtc={base_size:parseFloat(t).toString(),limit_price:parseFloat(e).toFixed(2)});const d={client_order_id:crypto.randomUUID(),product_id:y,side:a.toUpperCase(),order_configuration:f},w=await this._coinbaseRequest(i.creds,"POST","/api/v3/brokerage/orders",d);if(!w.success){const E=((b=w.error_response)==null?void 0:b.error)||((S=w.failure_response)==null?void 0:S.error)||((v=w.error_response)==null?void 0:v.message)||w.error||"Unknown error",T=((R=w.error_response)==null?void 0:R.error_details)||((I=w.failure_response)==null?void 0:I.message)||"";throw console.error("[COINBASE ORDER] FAILED:",E,T),new Error(`Coinbase order failed: ${E}${T?" â€” "+T:""}`)}const B=w.success_response||w,D=B.order_id||B.id;if(!D)throw console.error("[COINBASE ORDER] No order_id in response:",w),new Error("Coinbase: no order_id returned");let $=0,x=0,_="unknown";for(let E=0;E<3;E++)try{E>0&&await new Promise(V=>setTimeout(V,500));const T=await this._coinbaseRequest(i.creds,"GET",`/api/v3/brokerage/orders/historical/${D}`),P=T.order||T;if(_=(P.status||"").toUpperCase(),$=parseFloat(P.average_filled_price||0),x=parseFloat(P.filled_size||0),_==="FILLED"||_==="CANCELLED"||x>0)break}catch(T){console.warn(`[COINBASE ORDER] Detail fetch attempt ${E+1} failed:`,T.message)}return x===0&&$===0&&(console.warn("[COINBASE ORDER] Could not confirm fill for",D,"- status:",_),$=parseFloat(e||0),x=parseFloat(t),_="UNCONFIRMED"),{id:D,clientOrderId:d.client_order_id,symbol:y,side:a.toLowerCase(),type:r,quantity:x,price:$,filledPrice:$,filledQty:x,status:_.toLowerCase(),confirmed:_!=="UNCONFIRMED",timestamp:new Date().toISOString(),broker:"Coinbase",real:!0}}catch(y){throw console.error("[COINBASE ORDER] placeOrder error:",y.message),y}if(i.config.id==="bybit")try{const y=o.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase(),f={category:"spot",symbol:y,side:a.charAt(0).toUpperCase()+a.slice(1).toLowerCase(),orderType:r==="market"?"Market":"Limit",qty:t.toString()};r==="market"&&a.toLowerCase()==="buy"&&(f.marketUnit="quoteCoin",f.qty=(parseFloat(t)*parseFloat(e||0)).toFixed(2)),r==="limit"&&(f.price=parseFloat(e).toFixed(2),f.timeInForce="GTC");const w=(await this._bybitRequest(i.creds,"POST","/v5/order/create",f)).orderId||Date.now().toString(36);let B=parseFloat(e||0),D=parseFloat(t);try{await new Promise(_=>setTimeout(_,500));const $=await this._bybitRequest(i.creds,"GET","/v5/order/realtime",{category:"spot",orderId:w}),x=(A=$==null?void 0:$.list)==null?void 0:A[0];x&&(B=parseFloat(x.avgPrice||x.price||e||0),D=parseFloat(x.cumExecQty||t))}catch{}return{id:w,symbol:y,side:a.toLowerCase(),type:r,quantity:D,price:B,filledPrice:B,filledQty:D,status:"filled",timestamp:new Date().toISOString(),broker:"Bybit",real:!0}}catch(y){throw console.error("Bybit placeOrder:",y),y}if(i.config.id==="kraken")try{const y=o.replace("BTC","XBT"),f={pair:y,type:a.toLowerCase(),ordertype:r==="market"?"market":"limit",volume:t.toString()};r==="limit"&&(f.price=parseFloat(e).toFixed(2));const d=await this._krakenRequest(i.creds,"/0/private/AddOrder",f);return{id:((F=d==null?void 0:d.txid)==null?void 0:F[0])||Date.now().toString(36),symbol:y,side:a.toLowerCase(),type:r,quantity:parseFloat(t),price:parseFloat(e||0),filledPrice:parseFloat(e||0),filledQty:parseFloat(t),status:"filled",timestamp:new Date().toISOString(),broker:"Kraken",real:!0}}catch(y){throw console.error("Kraken placeOrder:",y),y}if(i.config.id==="kucoin")try{const y=o.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase(),f={clientOid:crypto.randomUUID(),symbol:y,side:a.toLowerCase(),type:r==="market"?"market":"limit"};r==="market"?a.toLowerCase()==="buy"?f.funds=(parseFloat(t)*parseFloat(e||0)).toFixed(2):f.size=t.toString():(f.price=parseFloat(e).toFixed(2),f.size=t.toString());const d=await this._kucoinRequest(i.creds,"POST","/api/v1/orders",f);return{id:(d==null?void 0:d.orderId)||Date.now().toString(36),symbol:y,side:a.toLowerCase(),type:r,quantity:parseFloat(t),price:parseFloat(e||0),filledPrice:parseFloat(e||0),filledQty:parseFloat(t),status:"filled",timestamp:new Date().toISOString(),broker:"KuCoin",real:!0}}catch(y){throw console.error("KuCoin placeOrder:",y),y}if(i.config.id==="okx")try{const y=o.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase(),f={instId:y,tdMode:"cash",side:a.toLowerCase(),ordType:r==="market"?"market":"limit",sz:t.toString()};r==="market"&&a.toLowerCase()==="buy"&&(f.tgtCcy="quote_ccy",f.sz=(parseFloat(t)*parseFloat(e||0)).toFixed(2)),r==="limit"&&(f.px=parseFloat(e).toFixed(2));const d=await this._okxRequest(i.creds,"POST","/api/v5/trade/order",f),w=Array.isArray(d)?(U=d[0])==null?void 0:U.ordId:(d==null?void 0:d.ordId)||Date.now().toString(36);if(Array.isArray(d)&&((O=d[0])==null?void 0:O.sCode)!=="0")throw new Error(`OKX order failed: ${(M=d[0])==null?void 0:M.sMsg}`);return{id:w,symbol:y,side:a.toLowerCase(),type:r,quantity:parseFloat(t),price:parseFloat(e||0),filledPrice:parseFloat(e||0),filledQty:parseFloat(t),status:"filled",timestamp:new Date().toISOString(),broker:"OKX",real:!0}}catch(y){throw console.error("OKX placeOrder:",y),y}if(i.config.id==="bingx")try{const y=o.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase(),f={symbol:y,side:a.toUpperCase(),type:r==="market"?"MARKET":"LIMIT"};r==="market"?a.toLowerCase()==="buy"?f.quoteOrderQty=(parseFloat(t)*parseFloat(e||0)).toFixed(2):f.quantity=parseFloat(t).toString():(f.price=parseFloat(e).toFixed(2),f.quantity=parseFloat(t).toString());const d=await this._bingxRequest(i.creds,"POST","/openApi/spot/v1/trade/order",f),w=(d==null?void 0:d.orderId)||((G=d==null?void 0:d.data)==null?void 0:G.orderId)||Date.now().toString(36);return{id:w==null?void 0:w.toString(),symbol:y,side:a.toLowerCase(),type:r,quantity:parseFloat(t),price:parseFloat(e||0),filledPrice:parseFloat((d==null?void 0:d.price)||e||0),filledQty:parseFloat((d==null?void 0:d.executedQty)||t),status:"filled",timestamp:new Date().toISOString(),broker:"BingX",real:!0}}catch(y){throw console.error("BingX placeOrder:",y),y}if(i.config.id==="bitget")try{const y=o.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase(),f={symbol:y,side:a.toLowerCase(),orderType:r==="market"?"market":"limit",force:"gtc",size:t.toString()};r==="market"&&a.toLowerCase()==="buy"&&(f.size=(parseFloat(t)*parseFloat(e||0)).toFixed(2)),r==="limit"&&(f.price=parseFloat(e).toFixed(2));const d=await this._bitgetRequest(i.creds,"POST","/api/v2/spot/trade/place-order",f),w=(d==null?void 0:d.orderId)||Date.now().toString(36);return{id:w==null?void 0:w.toString(),symbol:y,side:a.toLowerCase(),type:r,quantity:parseFloat(t),price:parseFloat(e||0),filledPrice:parseFloat(e||0),filledQty:parseFloat(t),status:"filled",timestamp:new Date().toISOString(),broker:"Bitget",real:!0}}catch(y){throw console.error("Bitget placeOrder:",y),y}if(i.config.id==="mexc")try{const y=o.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase(),f={symbol:y,side:a.toUpperCase(),type:r==="market"?"MARKET":"LIMIT"};r==="market"?a.toLowerCase()==="buy"?f.quoteOrderQty=(parseFloat(t)*parseFloat(e||0)).toFixed(2):f.quantity=parseFloat(t).toString():(f.price=parseFloat(e).toFixed(2),f.quantity=parseFloat(t).toString(),f.timeInForce="GTC");const d=await this._mexcRequest(i.creds,"POST","/api/v3/order",f),w=(d==null?void 0:d.orderId)||Date.now().toString(36);return{id:w==null?void 0:w.toString(),symbol:y,side:a.toLowerCase(),type:r,quantity:parseFloat(t),price:parseFloat(e||0),filledPrice:parseFloat((d==null?void 0:d.price)||e||0),filledQty:parseFloat((d==null?void 0:d.executedQty)||t),status:"filled",timestamp:new Date().toISOString(),broker:"MEXC",real:!0}}catch(y){throw console.error("MEXC placeOrder:",y),y}if(i.config.id==="wallet")try{const y=i.chainId||56,f=i.creds.apiSecret,d=await ae.placeOrder(f,y,{symbol:o,side:a,type:"market",quantity:t,price:e});if(!d.success)throw new Error(d.error||"DEX swap failed");return{id:d.txHash||Date.now().toString(36),symbol:d.symbol||o,side:a.toLowerCase(),type:"market",quantity:parseFloat(d.amountIn||t),price:parseFloat(d.effectivePrice||e||0),filledPrice:parseFloat(d.effectivePrice||e||0),filledQty:parseFloat(d.amountOut||t),status:"filled",timestamp:new Date().toISOString(),broker:d.mode==="aggregator"?"Kairos Exchange":"Kairos Wallet",real:!0,txHash:d.txHash,chain:d.chain,dex:d.dex,mode:d.mode,sources:d.sources,sourceSummary:d.sourceSummary}}catch(y){throw console.error("Wallet DEX placeOrder:",y),y}return{id:Date.now().toString(36),symbol:o,side:a,type:r,quantity:parseFloat(t),price:e?parseFloat(e):null,status:r==="market"?"filled":"new",filledPrice:r==="market"?parseFloat(e||0):null,timestamp:new Date().toISOString(),broker:i.config.name,simulated:!0}}async placeLeveragedOrder(c,s){var h;this.connections.get(c);const{symbol:i,side:o,quantity:a,price:r,leverage:t,action:e,positionId:n,stopLoss:l,takeProfit:u,execRoute:m}=s,p=(h=X.getState().user)==null?void 0:h.walletAddress;if(!p)throw new Error("Wallet address required for leveraged trading");const g=m==="dex"?`${W}/api/perps`:`${W}/api/margin`;if(e==="close"&&n)try{const C=await fetch(`${g}/close`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({wallet:p,positionId:n})}),b=await C.json();if(!C.ok||b.error)throw new Error(b.error||"Close position failed");const S=b.data||b;return{id:n,symbol:i,side:o.toLowerCase(),type:"market",quantity:parseFloat(S.collateral||a),price:parseFloat(S.exitPrice||r||0),filledPrice:parseFloat(S.exitPrice||r||0),filledQty:parseFloat(S.positionSize||a),profit:parseFloat(S.realizedPnl||S.pnl||0),status:"filled",timestamp:new Date().toISOString(),broker:"Kairos Perps",real:!0,leveraged:!0,leverage:t,action:"close"}}catch(C){throw console.error("[LEVERAGED] Close error:",C.message),C}try{const C=o.toLowerCase()==="buy"?"LONG":"SHORT",b=parseFloat(a)*parseFloat(r||1);let S=i;const v=i.match(/^([A-Z]+)(KAIROS|USDT|USDC|USD)$/i);v&&(S=`${v[1]}/${v[2]==="KAIROS"?"KAIROS":"USD"}`);const R=await fetch(`${g}/open`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({wallet:p,pair:S,side:C,leverage:parseInt(t)||3,collateral:b,stopLoss:l||void 0,takeProfit:u||void 0})}),I=await R.json();if(!R.ok||I.error)throw new Error(I.error||"Open position failed");const A=I.data||I;return{id:A.id||A.positionId||Date.now().toString(36),symbol:i,side:o.toLowerCase(),type:"market",quantity:parseFloat(A.collateral||b),price:parseFloat(A.entryPrice||r||0),filledPrice:parseFloat(A.entryPrice||r||0),filledQty:parseFloat(A.positionSize||b*t),status:"filled",timestamp:new Date().toISOString(),broker:"Kairos Perps",real:!0,leveraged:!0,leverage:parseInt(t),positionId:A.id||A.positionId,liquidationPrice:A.liquidationPrice,marginRatio:A.marginRatio,action:"open"}}catch(C){throw console.error("[LEVERAGED] Open error:",C.message),C}}async closeLeveragedPosition(c,{positionId:s,symbol:i,side:o,price:a,leverage:r}){return this.placeLeveragedOrder(c,{symbol:i,side:o==="buy"?"sell":"buy",quantity:0,price:a,leverage:r,action:"close",positionId:s})}async cancelOrder(c,s,i){const o=this.connections.get(c);if(!o)throw new Error("Broker not connected");if(o.config.id==="binance")try{const a=await this._binanceSignedRequest(o.creds,"DELETE","/api/v3/order",{symbol:i,orderId:s});return{success:!0,orderId:a.orderId,status:a.status}}catch(a){return{success:!1,message:a.message}}if(o.config.id==="coinbase")try{return await this._coinbaseRequest(o.creds,"POST","/api/v3/brokerage/orders/batch_cancel",{order_ids:[s]}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(o.config.id==="bybit")try{return await this._bybitRequest(o.creds,"POST","/v5/order/cancel",{category:"spot",symbol:i,orderId:s}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(o.config.id==="kraken")try{return await this._krakenRequest(o.creds,"/0/private/CancelOrder",{txid:s}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(o.config.id==="kucoin")try{return await this._kucoinRequest(o.creds,"DELETE",`/api/v1/orders/${s}`),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(o.config.id==="okx")try{return await this._okxRequest(o.creds,"POST","/api/v5/trade/cancel-order",{instId:i,ordId:s}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(o.config.id==="bingx")try{return await this._bingxRequest(o.creds,"POST","/openApi/spot/v1/trade/cancel",{symbol:i,orderId:s}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(o.config.id==="bitget")try{return await this._bitgetRequest(o.creds,"POST","/api/v2/spot/trade/cancel-order",{symbol:i,orderId:s}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}if(o.config.id==="mexc")try{return await this._mexcRequest(o.creds,"DELETE","/api/v3/order",{symbol:i,orderId:s}),{success:!0,orderId:s}}catch(a){return{success:!1,message:a.message}}return o.config.id==="wallet"?{success:!1,message:"DEX orders are instant swaps and cannot be cancelled"}:{success:!0,orderId:s,simulated:!0}}async getOpenOrders(c,s){const i=this.connections.get(c);if(!i)throw new Error("Broker not connected");if(i.config.id==="binance")try{const o=s?{symbol:s}:{};return(await this._binanceSignedRequest(i.creds,"GET","/api/v3/openOrders",o)).map(r=>{var t,e,n,l;return{id:(t=r.orderId)==null?void 0:t.toString(),symbol:r.symbol,side:(e=r.side)==null?void 0:e.toLowerCase(),type:(n=r.type)==null?void 0:n.toLowerCase(),quantity:parseFloat(r.origQty),price:parseFloat(r.price),filledQty:parseFloat(r.executedQty),status:(l=r.status)==null?void 0:l.toLowerCase(),time:new Date(r.time).toISOString()}})}catch{return[]}if(i.config.id==="coinbase")try{const o=s?s.replace(/([A-Z]+)(USDT|USDC|USD|BTC|ETH)$/i,"$1-$2").toUpperCase():void 0;let a="/api/v3/brokerage/orders/historical/batch?order_status=OPEN";return o&&(a+=`&product_id=${o}`),((await this._coinbaseRequest(i.creds,"GET",a)).orders||[]).map(t=>{var e,n,l,u,m,p,g;return{id:t.order_id,symbol:t.product_id,side:(e=t.side)==null?void 0:e.toLowerCase(),type:(n=t.order_type)==null?void 0:n.toLowerCase(),quantity:parseFloat(((u=(l=t.order_configuration)==null?void 0:l.limit_limit_gtc)==null?void 0:u.base_size)||0),price:parseFloat(((p=(m=t.order_configuration)==null?void 0:m.limit_limit_gtc)==null?void 0:p.limit_price)||t.average_filled_price||0),filledQty:parseFloat(t.filled_size||0),status:(g=t.status)==null?void 0:g.toLowerCase(),time:t.created_time}})}catch(o){return console.error("[COINBASE] getOpenOrders error:",o.message),[]}if(i.config.id==="bybit")try{const o={category:"spot"};s&&(o.symbol=s);const a=await this._bybitRequest(i.creds,"GET","/v5/order/realtime",o);return((a==null?void 0:a.list)||[]).map(r=>{var t,e,n;return{id:r.orderId,symbol:r.symbol,side:(t=r.side)==null?void 0:t.toLowerCase(),type:(e=r.orderType)==null?void 0:e.toLowerCase(),quantity:parseFloat(r.qty||0),price:parseFloat(r.price||0),filledQty:parseFloat(r.cumExecQty||0),status:(n=r.orderStatus)==null?void 0:n.toLowerCase(),time:r.createdTime?new Date(parseInt(r.createdTime)).toISOString():null}})}catch(o){return console.error("Bybit getOpenOrders:",o.message),[]}if(i.config.id==="kraken")try{const o=await this._krakenRequest(i.creds,"/0/private/OpenOrders"),a=(o==null?void 0:o.open)||{};return Object.entries(a).map(([r,t])=>{var e,n,l,u,m,p,g;return{id:r,symbol:((e=t.descr)==null?void 0:e.pair)||"",side:(l=(n=t.descr)==null?void 0:n.type)==null?void 0:l.toLowerCase(),type:(m=(u=t.descr)==null?void 0:u.ordertype)==null?void 0:m.toLowerCase(),quantity:parseFloat(t.vol||0),price:parseFloat(((p=t.descr)==null?void 0:p.price)||0),filledQty:parseFloat(t.vol_exec||0),status:((g=t.status)==null?void 0:g.toLowerCase())||"open",time:t.opentm?new Date(t.opentm*1e3).toISOString():null}})}catch(o){return console.error("Kraken getOpenOrders:",o.message),[]}if(i.config.id==="kucoin")try{const o={status:"active"};s&&(o.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const a=await this._kucoinRequest(i.creds,"GET","/api/v1/orders",o);return(Array.isArray(a==null?void 0:a.items)?a.items:Array.isArray(a)?a:[]).map(t=>{var e,n;return{id:t.id,symbol:t.symbol,side:(e=t.side)==null?void 0:e.toLowerCase(),type:(n=t.type)==null?void 0:n.toLowerCase(),quantity:parseFloat(t.size||0),price:parseFloat(t.price||0),filledQty:parseFloat(t.dealSize||0),status:t.isActive?"open":"done",time:t.createdAt?new Date(parseInt(t.createdAt)).toISOString():null}})}catch(o){return console.error("KuCoin getOpenOrders:",o.message),[]}if(i.config.id==="okx")try{const o={instType:"SPOT"};s&&(o.instId=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const a=await this._okxRequest(i.creds,"GET","/api/v5/trade/orders-pending",o);return(Array.isArray(a)?a:[]).map(t=>{var e,n,l;return{id:t.ordId,symbol:t.instId,side:(e=t.side)==null?void 0:e.toLowerCase(),type:(n=t.ordType)==null?void 0:n.toLowerCase(),quantity:parseFloat(t.sz||0),price:parseFloat(t.px||0),filledQty:parseFloat(t.accFillSz||0),status:((l=t.state)==null?void 0:l.toLowerCase())||"open",time:t.cTime?new Date(parseInt(t.cTime)).toISOString():null}})}catch(o){return console.error("OKX getOpenOrders:",o.message),[]}if(i.config.id==="bingx")try{const o={};s&&(o.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const a=await this._bingxRequest(i.creds,"GET","/openApi/spot/v1/trade/openOrders",o);return((a==null?void 0:a.orders)||(Array.isArray(a)?a:[])).map(t=>{var e,n,l,u;return{id:(e=t.orderId)==null?void 0:e.toString(),symbol:t.symbol,side:(n=t.side)==null?void 0:n.toLowerCase(),type:(l=t.type)==null?void 0:l.toLowerCase(),quantity:parseFloat(t.origQty||0),price:parseFloat(t.price||0),filledQty:parseFloat(t.executedQty||0),status:((u=t.status)==null?void 0:u.toLowerCase())||"open",time:t.time?new Date(parseInt(t.time)).toISOString():null}})}catch(o){return console.error("BingX getOpenOrders:",o.message),[]}if(i.config.id==="bitget")try{const o={};s&&(o.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase());const a=await this._bitgetRequest(i.creds,"GET","/api/v2/spot/trade/unfilled-orders",o);return(Array.isArray(a)?a:[]).map(t=>{var e,n,l;return{id:t.orderId,symbol:t.symbol,side:(e=t.side)==null?void 0:e.toLowerCase(),type:(n=t.orderType)==null?void 0:n.toLowerCase(),quantity:parseFloat(t.size||0),price:parseFloat(t.price||0),filledQty:parseFloat(t.baseVolume||0),status:((l=t.status)==null?void 0:l.toLowerCase())||"open",time:t.cTime?new Date(parseInt(t.cTime)).toISOString():null}})}catch(o){return console.error("Bitget getOpenOrders:",o.message),[]}if(i.config.id==="mexc")try{const o={};s&&(o.symbol=s);const a=await this._mexcRequest(i.creds,"GET","/api/v3/openOrders",o);return(Array.isArray(a)?a:[]).map(t=>{var e,n,l,u;return{id:(e=t.orderId)==null?void 0:e.toString(),symbol:t.symbol,side:(n=t.side)==null?void 0:n.toLowerCase(),type:(l=t.type)==null?void 0:l.toLowerCase(),quantity:parseFloat(t.origQty||0),price:parseFloat(t.price||0),filledQty:parseFloat(t.executedQty||0),status:((u=t.status)==null?void 0:u.toLowerCase())||"open",time:t.time?new Date(t.time).toISOString():null}})}catch(o){return console.error("MEXC getOpenOrders:",o.message),[]}return[]}async getClosedOrders(c,s,i=50){const o=this.connections.get(c);if(!o)throw new Error("Broker not connected");const a=(r,t)=>{var e;return{id:((e=r[t.id])==null?void 0:e.toString())||"",symbol:r[t.symbol]||"",side:(r[t.side]||"").toLowerCase(),type:(r[t.type]||"").toLowerCase(),quantity:parseFloat(r[t.qty]||0),price:parseFloat(r[t.price]||0),filledQty:parseFloat(r[t.filledQty]||0),avgPrice:parseFloat(r[t.avgPrice]||r[t.price]||0),status:(r[t.status]||"closed").toLowerCase(),time:t.timeFn?t.timeFn(r):null}};if(o.config.id==="binance")try{const r={limit:i};s&&(r.symbol=s);const t=await this._binanceSignedRequest(o.creds,"GET","/api/v3/allOrders",r);return(Array.isArray(t)?t:[]).filter(n=>n.status!=="NEW"&&n.status!=="PARTIALLY_FILLED").map(n=>a(n,{id:"orderId",symbol:"symbol",side:"side",type:"type",qty:"origQty",price:"price",filledQty:"executedQty",avgPrice:"price",status:"status",timeFn:l=>l.time?new Date(l.time).toISOString():null}))}catch(r){return console.error("Binance getClosedOrders:",r.message),[]}if(o.config.id==="coinbase")try{const r={order_status:["FILLED","CANCELLED","EXPIRED"],limit:i};s&&(r.product_id=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const t=await this._coinbaseRequest(o.creds,"GET","/api/v3/brokerage/orders/historical/batch",r);return((t==null?void 0:t.orders)||[]).map(e=>a(e,{id:"order_id",symbol:"product_id",side:"side",type:"order_type",qty:"base_size",price:"average_filled_price",filledQty:"filled_size",avgPrice:"average_filled_price",status:"status",timeFn:n=>n.created_time||null}))}catch(r){return console.error("Coinbase getClosedOrders:",r.message),[]}if(o.config.id==="bybit")try{const r={category:"spot",limit:i.toString()};s&&(r.symbol=s);const t=await this._bybitRequest(o.creds,"GET","/v5/order/history",r);return((t==null?void 0:t.list)||[]).map(e=>a(e,{id:"orderId",symbol:"symbol",side:"side",type:"orderType",qty:"qty",price:"price",filledQty:"cumExecQty",avgPrice:"avgPrice",status:"orderStatus",timeFn:n=>n.createdTime?new Date(parseInt(n.createdTime)).toISOString():null}))}catch(r){return console.error("Bybit getClosedOrders:",r.message),[]}if(o.config.id==="kraken")try{const r=await this._krakenRequest(o.creds,"/0/private/ClosedOrders"),t=(r==null?void 0:r.closed)||{};return Object.entries(t).slice(0,i).map(([e,n])=>{var l,u,m,p,g;return{id:e,symbol:((l=n.descr)==null?void 0:l.pair)||"",side:(((u=n.descr)==null?void 0:u.type)||"").toLowerCase(),type:(((m=n.descr)==null?void 0:m.ordertype)||"").toLowerCase(),quantity:parseFloat(n.vol||0),price:parseFloat(((p=n.descr)==null?void 0:p.price)||0),filledQty:parseFloat(n.vol_exec||0),avgPrice:parseFloat(n.price||((g=n.descr)==null?void 0:g.price)||0),status:(n.status||"closed").toLowerCase(),time:n.closetm?new Date(n.closetm*1e3).toISOString():null}})}catch(r){return console.error("Kraken getClosedOrders:",r.message),[]}if(o.config.id==="kucoin")try{const r={status:"done"};s&&(r.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const t=await this._kucoinRequest(o.creds,"GET","/api/v1/orders",r);return(Array.isArray(t==null?void 0:t.items)?t.items:Array.isArray(t)?t:[]).slice(0,i).map(n=>a(n,{id:"id",symbol:"symbol",side:"side",type:"type",qty:"size",price:"price",filledQty:"dealSize",avgPrice:"dealFunds",status:"status",timeFn:l=>l.createdAt?new Date(parseInt(l.createdAt)).toISOString():null}))}catch(r){return console.error("KuCoin getClosedOrders:",r.message),[]}if(o.config.id==="okx")try{const r={instType:"SPOT"};s&&(r.instId=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const t=await this._okxRequest(o.creds,"GET","/api/v5/trade/orders-history-archive",r);return(Array.isArray(t)?t:[]).slice(0,i).map(n=>a(n,{id:"ordId",symbol:"instId",side:"side",type:"ordType",qty:"sz",price:"px",filledQty:"accFillSz",avgPrice:"avgPx",status:"state",timeFn:l=>l.cTime?new Date(parseInt(l.cTime)).toISOString():null}))}catch(r){return console.error("OKX getClosedOrders:",r.message),[]}if(o.config.id==="bingx")try{const r={limit:i.toString()};s&&(r.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const t=await this._bingxRequest(o.creds,"GET","/openApi/spot/v1/trade/historyOrders",r);return((t==null?void 0:t.orders)||(Array.isArray(t)?t:[])).map(n=>a(n,{id:"orderId",symbol:"symbol",side:"side",type:"type",qty:"origQty",price:"price",filledQty:"executedQty",avgPrice:"avgPrice",status:"status",timeFn:l=>l.time?new Date(parseInt(l.time)).toISOString():null}))}catch(r){return console.error("BingX getClosedOrders:",r.message),[]}if(o.config.id==="bitget")try{const r={limit:i.toString()};s&&(r.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase());const t=await this._bitgetRequest(o.creds,"GET","/api/v2/spot/trade/history-orders",r);return(Array.isArray(t)?t:[]).map(n=>a(n,{id:"orderId",symbol:"symbol",side:"side",type:"orderType",qty:"size",price:"price",filledQty:"baseVolume",avgPrice:"priceAvg",status:"status",timeFn:l=>l.cTime?new Date(parseInt(l.cTime)).toISOString():null}))}catch(r){return console.error("Bitget getClosedOrders:",r.message),[]}if(o.config.id==="mexc")try{const r={limit:i};s&&(r.symbol=s);const t=await this._mexcRequest(o.creds,"GET","/api/v3/allOrders",r);return(Array.isArray(t)?t:[]).filter(n=>n.status!=="NEW").map(n=>a(n,{id:"orderId",symbol:"symbol",side:"side",type:"type",qty:"origQty",price:"price",filledQty:"executedQty",avgPrice:"price",status:"status",timeFn:l=>l.time?new Date(l.time).toISOString():null}))}catch(r){return console.error("MEXC getClosedOrders:",r.message),[]}return[]}async getTradeHistory(c,s,i=50){const o=this.connections.get(c);if(!o)throw new Error("Broker not connected");if(o.config.id==="binance")try{return(await this._binanceSignedRequest(o.creds,"GET","/api/v3/myTrades",{symbol:s,limit:i})).map(r=>{var t,e;return{id:(t=r.id)==null?void 0:t.toString(),orderId:(e=r.orderId)==null?void 0:e.toString(),symbol:r.symbol,side:r.isBuyer?"buy":"sell",price:parseFloat(r.price),quantity:parseFloat(r.qty),commission:parseFloat(r.commission),commissionAsset:r.commissionAsset,time:new Date(r.time).toISOString(),isMaker:r.isMaker}})}catch{return[]}if(o.config.id==="coinbase")try{const a=s?s.replace(/([A-Z]+)(USDT|USDC|USD|BTC|ETH)$/i,"$1-$2").toUpperCase():void 0;let r=`/api/v3/brokerage/orders/historical/fills?limit=${i}`;return a&&(r+=`&product_id=${a}`),((await this._coinbaseRequest(o.creds,"GET",r)).fills||[]).map(e=>{var n,l,u;return{id:e.trade_id||e.entry_id,orderId:e.order_id,symbol:e.product_id,side:(n=e.side)==null?void 0:n.toLowerCase(),price:parseFloat(e.price||0),quantity:parseFloat(e.size||e.size_in_quote||0),commission:parseFloat(e.commission||0),commissionAsset:((u=(l=e.product_id)==null?void 0:l.split("-"))==null?void 0:u[1])||"USD",time:e.trade_time,isMaker:!1}})}catch(a){return console.error("[COINBASE] getTradeHistory error:",a.message),[]}if(o.config.id==="bybit")try{const a={category:"spot",limit:i.toString()};s&&(a.symbol=s);const r=await this._bybitRequest(o.creds,"GET","/v5/execution/list",a);return((r==null?void 0:r.list)||[]).map(t=>{var e;return{id:t.execId,orderId:t.orderId,symbol:t.symbol,side:(e=t.side)==null?void 0:e.toLowerCase(),price:parseFloat(t.execPrice||0),quantity:parseFloat(t.execQty||0),commission:parseFloat(t.execFee||0),commissionAsset:t.feeCurrency||"",time:t.execTime?new Date(parseInt(t.execTime)).toISOString():null,isMaker:t.isMaker==="true"||t.isMaker===!0}})}catch(a){return console.error("Bybit getTradeHistory:",a.message),[]}if(o.config.id==="kraken")try{const a=await this._krakenRequest(o.creds,"/0/private/TradesHistory"),r=(a==null?void 0:a.trades)||{};return Object.entries(r).slice(0,i).map(([t,e])=>{var n;return{id:t,orderId:e.ordertxid,symbol:e.pair,side:(n=e.type)==null?void 0:n.toLowerCase(),price:parseFloat(e.price||0),quantity:parseFloat(e.vol||0),commission:parseFloat(e.fee||0),commissionAsset:"",time:e.time?new Date(e.time*1e3).toISOString():null,isMaker:e.maker===!0}})}catch(a){return console.error("Kraken getTradeHistory:",a.message),[]}if(o.config.id==="kucoin")try{const a={};s&&(a.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const r=await this._kucoinRequest(o.creds,"GET","/api/v1/fills",a);return(Array.isArray(r==null?void 0:r.items)?r.items:Array.isArray(r)?r:[]).slice(0,i).map(e=>{var n;return{id:e.tradeId||e.id,orderId:e.orderId,symbol:e.symbol,side:(n=e.side)==null?void 0:n.toLowerCase(),price:parseFloat(e.price||0),quantity:parseFloat(e.size||0),commission:parseFloat(e.fee||0),commissionAsset:e.feeCurrency||"",time:e.createdAt?new Date(parseInt(e.createdAt)).toISOString():null,isMaker:e.liquidity==="maker"}})}catch(a){return console.error("KuCoin getTradeHistory:",a.message),[]}if(o.config.id==="okx")try{const a={instType:"SPOT"};s&&(a.instId=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const r=await this._okxRequest(o.creds,"GET","/api/v5/trade/fills-history",a);return(Array.isArray(r)?r:[]).slice(0,i).map(e=>{var n;return{id:e.tradeId||e.billId,orderId:e.ordId,symbol:e.instId,side:(n=e.side)==null?void 0:n.toLowerCase(),price:parseFloat(e.fillPx||0),quantity:parseFloat(e.fillSz||0),commission:Math.abs(parseFloat(e.fee||0)),commissionAsset:e.feeCcy||"",time:e.ts?new Date(parseInt(e.ts)).toISOString():null,isMaker:e.execType==="M"}})}catch(a){return console.error("OKX getTradeHistory:",a.message),[]}if(o.config.id==="bingx")try{const a={limit:i.toString()};s&&(a.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1-$2").toUpperCase());const r=await this._bingxRequest(o.creds,"GET","/openApi/spot/v1/trade/historyOrders",a);return((r==null?void 0:r.orders)||(Array.isArray(r)?r:[])).map(e=>{var n,l,u;return{id:(n=e.orderId)==null?void 0:n.toString(),orderId:(l=e.orderId)==null?void 0:l.toString(),symbol:e.symbol,side:(u=e.side)==null?void 0:u.toLowerCase(),price:parseFloat(e.price||e.avgPrice||0),quantity:parseFloat(e.executedQty||e.origQty||0),commission:parseFloat(e.commission||0),commissionAsset:e.commissionAsset||"",time:e.time?new Date(parseInt(e.time)).toISOString():null,isMaker:!1}})}catch(a){return console.error("BingX getTradeHistory:",a.message),[]}if(o.config.id==="bitget")try{const a={limit:i.toString()};s&&(a.symbol=s.replace(/([A-Z]+)(USDT|USDC|USD)$/i,"$1$2").toUpperCase());const r=await this._bitgetRequest(o.creds,"GET","/api/v2/spot/trade/fills",a);return(Array.isArray(r)?r:[]).map(e=>{var n;return{id:e.tradeId||e.fillId,orderId:e.orderId,symbol:e.symbol,side:(n=e.side)==null?void 0:n.toLowerCase(),price:parseFloat(e.priceAvg||e.price||0),quantity:parseFloat(e.size||0),commission:parseFloat(e.fees||e.fee||0),commissionAsset:e.feeCcy||"",time:e.cTime?new Date(parseInt(e.cTime)).toISOString():null,isMaker:e.tradeScope==="maker"}})}catch(a){return console.error("Bitget getTradeHistory:",a.message),[]}if(o.config.id==="mexc")try{const a={limit:i};s&&(a.symbol=s);const r=await this._mexcRequest(o.creds,"GET","/api/v3/myTrades",a);return(Array.isArray(r)?r:[]).map(e=>{var n,l;return{id:(n=e.id)==null?void 0:n.toString(),orderId:(l=e.orderId)==null?void 0:l.toString(),symbol:e.symbol,side:e.isBuyer?"buy":"sell",price:parseFloat(e.price||0),quantity:parseFloat(e.qty||0),commission:parseFloat(e.commission||0),commissionAsset:e.commissionAsset||"",time:e.time?new Date(e.time).toISOString():null,isMaker:e.isMaker===!0}})}catch(a){return console.error("MEXC getTradeHistory:",a.message),[]}return[]}async getExchangeInfo(c){var s,i,o,a;try{const t=(s=(await this._binancePublicRequest("/api/v3/exchangeInfo",{symbol:c})).symbols)==null?void 0:s[0];if(!t)return null;const e=(i=t.filters)==null?void 0:i.find(u=>u.filterType==="LOT_SIZE"),n=(o=t.filters)==null?void 0:o.find(u=>u.filterType==="PRICE_FILTER"),l=(a=t.filters)==null?void 0:a.find(u=>u.filterType==="NOTIONAL"||u.filterType==="MIN_NOTIONAL");return{symbol:t.symbol,status:t.status,baseAsset:t.baseAsset,quoteAsset:t.quoteAsset,minQty:e?parseFloat(e.minQty):0,maxQty:e?parseFloat(e.maxQty):1/0,stepSize:e?parseFloat(e.stepSize):0,minPrice:n?parseFloat(n.minPrice):0,tickSize:n?parseFloat(n.tickSize):0,minNotional:l?parseFloat(l.minNotional||l.notional):0}}catch{return null}}isConnected(c){return this.connections.has(c)}getConnection(c){return this.connections.get(c)}disconnect(c){this.connections.delete(c)}}const ie=new se;export{ie as b};
//# sourceMappingURL=broker-Bnxr9sTZ.js.map
