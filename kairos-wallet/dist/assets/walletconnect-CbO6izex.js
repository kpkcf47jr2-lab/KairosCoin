import{b as R,i as b,G as C,z as d}from"./walletconnect-BHdiBbF1.js";import{E as x}from"./index-1fU2ylg1.js";import{Wallet as q,getBytes as E,isHexString as j}from"./crypto-1JBTrmrY.js";import"./ui-BteoE537.js";import"./vendor-cxSnwWPt.js";const k="2b0ddf4a2e6e6a53f52d2bcb9a0c2e0f";let c=null,T=null,g=null,h=null,f=null;async function r(){if(c)return c;try{return T=new R({projectId:k}),c=await b.init({core:T,metadata:{name:"Kairos Wallet",description:"Billetera DeFi multi-chain",url:"https://kairos-wallet.netlify.app",icons:["https://kairos-wallet.netlify.app/icons/logo-192.png"]}}),c.on("session_proposal",s=>{g&&g(s)}),c.on("session_request",s=>{h&&h(s)}),c.on("session_delete",s=>{f&&f(s)}),c}catch(s){throw console.error("WalletConnect init error:",s),s}}function U({onProposal:s,onRequest:a,onDelete:o}){g=s,h=a,f=o}async function $(s){await(await r()).pair({uri:s})}async function A(s,a,o){const p=await r(),l=o.map(n=>`eip155:${n}`),w=o.map(n=>`eip155:${n}:${a}`),t=["eth_sendTransaction","eth_signTransaction","eth_sign","personal_sign","eth_signTypedData","eth_signTypedData_v4"],u=["chainChanged","accountsChanged"],m=C({proposal:s.params,supportedNamespaces:{eip155:{chains:l,methods:t,events:u,accounts:w}}});return await p.approveSession({id:s.id,namespaces:m})}async function M(s){await(await r()).rejectSession({id:s,reason:d("USER_REJECTED")})}async function z(s,a){const o=await r(),{topic:p,id:l,params:w}=s,{request:t,chainId:u}=w,m=parseInt(u.split(":")[1]),y=x(m),n=new q(a,y);let i;try{switch(t.method){case"personal_sign":{const e=t.params[0];i=await n.signMessage(j(e)?E(e):e);break}case"eth_sign":{const e=t.params[1];i=await n.signMessage(E(e));break}case"eth_signTypedData":case"eth_signTypedData_v4":{const e=JSON.parse(t.params[1]),{domain:S,types:v,message:D}=e,_={...v};delete _.EIP712Domain,i=await n.signTypedData(S,_,D);break}case"eth_sendTransaction":{const e=t.params[0];i=(await n.sendTransaction({to:e.to,value:e.value||"0x0",data:e.data||"0x",gasLimit:e.gas||e.gasLimit})).hash;break}case"eth_signTransaction":{const e=t.params[0];i=await n.signTransaction({to:e.to,value:e.value||"0x0",data:e.data||"0x",gasLimit:e.gas||e.gasLimit});break}default:throw new Error(`MÃ©todo no soportado: ${t.method}`)}return await o.respondSessionRequest({topic:p,response:{id:l,jsonrpc:"2.0",result:i}}),{success:!0,result:i}}catch(e){return await o.respondSessionRequest({topic:p,response:{id:l,jsonrpc:"2.0",error:d("USER_REJECTED")}}),{success:!1,error:e.message}}}async function B(s,a){await(await r()).respondSessionRequest({topic:s,response:{id:a,jsonrpc:"2.0",error:d("USER_REJECTED")}})}async function I(){const s=await r();return Object.values(s.getActiveSessions())}async function P(s){await(await r()).disconnectSession({topic:s,reason:d("USER_DISCONNECTED")})}async function G(){const s=await I();for(const a of s)try{await P(a.topic)}catch{}}export{A as approveSession,G as disconnectAll,P as disconnectSession,I as getActiveSessions,z as handleSessionRequest,r as initWalletConnect,$ as pair,M as rejectSession,B as rejectSessionRequest,U as setWCHandlers};
